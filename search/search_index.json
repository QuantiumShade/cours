{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"00_intro/","text":"Introduction \u00b6 Objectifs \u00b6 Le 1er objectif est de d\u00e9couvrir quel est le r\u00f4le d'un OS afin de pouvoir coder des programmes utilisant des processus / threads . Cela permettra de parall\u00e9liser des actions dans nos future programmes. Aussi, nous verrons de mani\u00e8re simplifi\u00e9e comment sont ordonnanc\u00e9s les processus, puis comment sont organis\u00e9s les fichiers. D\u00e9finition \u00b6 Un OS est la couche logicielle qui permet et coordonne l\u2019utilisation du mat\u00e9riel entre les diff\u00e9rents programmes d\u2019application. Tip C'est donc le lien entre l'homme et le hardware ! On parle d' IHM - Interface Homme Machine Example Quelques exemples d'OS : - Unix based : Linux, Mac, Android, iOS ... - Windows : XP, Vista, 7, 10 ... On peut voir l'OS de duex points de vues diff\u00e9rents : Utilisateur Lambda : Une IHM Un d\u00e9veloppeur : Un ensemble d'appels syst\u00e8mes Fonctions d'un OS \u00b6 Offrir une interface de programmation & interpreteur de commandes \u00b6 Un IDE, Une Command Line etc ... Offrir une interface op\u00e9rateur conviviale \u00b6 Pour les non programmeurs. Ceci n'est pas obligatoire ;) Optimiser l\u2019utilisation des \u00e9l\u00e9ments du syst\u00e8me informatique : \u00b6 Gestion du processeur \u00b6 Le syst\u00e8me doit g\u00e9rer l'allocation du processeur aux diff\u00e9rents programmes pouvant s'ex\u00e9cuter (les processus). Cette allocation se fait par le biais d'un algorithme d'ordonnancement qui planifie l'ex\u00e9cution des programmes. Selon le type de syst\u00e8me d'exploitation, l'algorithme d'ordonnancement r\u00e9pond \u00e0 des objectifs diff\u00e9rents (Ex. Syst\u00e8mes Temps R\u00e9el) 1 D\u00e9finition d'un Processus Processus = programme en cours d'ex\u00e9cution. 1 Processus poss\u00e8de trois \u00e9l\u00e9ments : programme ex\u00e9cutable donn\u00e9es associ\u00e9es au programme contexte d\u2019ex\u00e9cution du programme Gestion de la concurrence \u00b6 Comme plusieurs programmes coexistent en RAM, ceux-ci peuvent vouloir communiquer pour \u00e9changer des donn\u00e9es. Par ailleurs, il faut synchroniser l'acc\u00e8s aux donn\u00e9es partag\u00e9es afin de maintenir leur coh\u00e9rence. Le syst\u00e8me offre des outils de communication et de synchronisation entre programmes. Gestion de la m\u00e9moire \u00b6 Le syst\u00e8me doit g\u00e9rer l'allocation de la RAM entre les diff\u00e9rents programmes pouvant s'ex\u00e9cuter. Comme la m\u00e9moire physique est souvent trop petite pour contenir la totalit\u00e9 des programmes, la gestion de la m\u00e9moire se fait selon le principe de la m\u00e9moire virtuelle. A un instant donn\u00e9, seules sont charg\u00e9es en RAM les parties de code et donn\u00e9es utiles \u00e0 l'ex\u00e9cution. Ainsi, chacun des processus acc\u00e8de \u00e0 toute la m\u00e9moire \u00e0 un instant T. A cela on ajoute le m\u00e9canisme de SWAP qui permet de d\u00e9sengorger le syst\u00e8me en d\u00e9pla\u00e7ant des modules executables sur la m\u00e9moire secondaire (le HDD). C'est plus lent, mais au moins le syst\u00e8me continue de fonctionner ! Gestion des entr\u00e9es/sorties \u00b6 Le syst\u00e8me doit g\u00e9rer l'acc\u00e8s aux p\u00e9riph\u00e9riques, c'est-\u00e0-dire faire la liaison entre les appels de haut niveau des programmes utilisateurs (exemple getchar()) et les op\u00e9rations de bas niveau de l\u2018unit\u00e9 d\u2019ex\u00e9cution responsable du p\u00e9riph\u00e9rique (UE clavier) C'est le pilote d'entr\u00e9es/sorties (driver) qui assure cette correspondance. Gestion des objets externes \u00b6 La m\u00e9moire centrale est une m\u00e9moire volatile (RAM). Aussi, toutes les donn\u00e9es devant \u00eatre conserv\u00e9es au del\u00e0 de l'arr\u00eat de la machine, doivent \u00eatre stock\u00e9es sur une m\u00e9moire de masse ( disque dur ). Gestion de l\u2019acc\u00e8s au r\u00e9seau \u00b6 Le syst\u00e8me doit permettre \u00e0 des ex\u00e9cutions de programmes, plac\u00e9es sur des machines distinctes, de communiquer. Le syst\u00e8me offre des outils de type socket pour acc\u00e9der \u00e0 la couche de protocoles de communication. Gestion de la protection \u00b6 Le syst\u00e8me doit fournir des m\u00e9canismes garantissant que ses ressources (CPU, m\u00e9moire, fichiers,\u2026) ne peuvent \u00eatre utilis\u00e9es que par les programmes auxquels les droits n\u00e9cessaires ont \u00e9t\u00e9 accord\u00e9s. Syst\u00e8mes TR : Les programmes en ex\u00e9cution sont soumis \u00e0 des contraintes de temps fortes, c'est-\u00e0-dire que leurs ex\u00e9cutions doivent \u00eatre imp\u00e9rativement achev\u00e9es \u00e0 une date butoir appel\u00e9e \u00e9ch\u00e9ance (Robotique / S\u00e9curit\u00e9 / D\u00e9fense) \u21a9","title":"Introduction"},{"location":"00_intro/#introduction","text":"","title":"Introduction"},{"location":"00_intro/#objectifs","text":"Le 1er objectif est de d\u00e9couvrir quel est le r\u00f4le d'un OS afin de pouvoir coder des programmes utilisant des processus / threads . Cela permettra de parall\u00e9liser des actions dans nos future programmes. Aussi, nous verrons de mani\u00e8re simplifi\u00e9e comment sont ordonnanc\u00e9s les processus, puis comment sont organis\u00e9s les fichiers.","title":"Objectifs"},{"location":"00_intro/#definition","text":"Un OS est la couche logicielle qui permet et coordonne l\u2019utilisation du mat\u00e9riel entre les diff\u00e9rents programmes d\u2019application. Tip C'est donc le lien entre l'homme et le hardware ! On parle d' IHM - Interface Homme Machine Example Quelques exemples d'OS : - Unix based : Linux, Mac, Android, iOS ... - Windows : XP, Vista, 7, 10 ... On peut voir l'OS de duex points de vues diff\u00e9rents : Utilisateur Lambda : Une IHM Un d\u00e9veloppeur : Un ensemble d'appels syst\u00e8mes","title":"D\u00e9finition"},{"location":"00_intro/#fonctions-dun-os","text":"","title":"Fonctions d'un OS"},{"location":"00_intro/#offrir-une-interface-de-programmation-interpreteur-de-commandes","text":"Un IDE, Une Command Line etc ...","title":"Offrir une interface de programmation &amp; interpreteur de commandes"},{"location":"00_intro/#offrir-une-interface-operateur-conviviale","text":"Pour les non programmeurs. Ceci n'est pas obligatoire ;)","title":"Offrir une interface op\u00e9rateur conviviale"},{"location":"00_intro/#optimiser-lutilisation-des-elements-du-systeme-informatique","text":"","title":"Optimiser l\u2019utilisation des \u00e9l\u00e9ments du syst\u00e8me informatique :"},{"location":"00_intro/#gestion-du-processeur","text":"Le syst\u00e8me doit g\u00e9rer l'allocation du processeur aux diff\u00e9rents programmes pouvant s'ex\u00e9cuter (les processus). Cette allocation se fait par le biais d'un algorithme d'ordonnancement qui planifie l'ex\u00e9cution des programmes. Selon le type de syst\u00e8me d'exploitation, l'algorithme d'ordonnancement r\u00e9pond \u00e0 des objectifs diff\u00e9rents (Ex. Syst\u00e8mes Temps R\u00e9el) 1 D\u00e9finition d'un Processus Processus = programme en cours d'ex\u00e9cution. 1 Processus poss\u00e8de trois \u00e9l\u00e9ments : programme ex\u00e9cutable donn\u00e9es associ\u00e9es au programme contexte d\u2019ex\u00e9cution du programme","title":"Gestion du processeur"},{"location":"00_intro/#gestion-de-la-concurrence","text":"Comme plusieurs programmes coexistent en RAM, ceux-ci peuvent vouloir communiquer pour \u00e9changer des donn\u00e9es. Par ailleurs, il faut synchroniser l'acc\u00e8s aux donn\u00e9es partag\u00e9es afin de maintenir leur coh\u00e9rence. Le syst\u00e8me offre des outils de communication et de synchronisation entre programmes.","title":"Gestion de la concurrence"},{"location":"00_intro/#gestion-de-la-memoire","text":"Le syst\u00e8me doit g\u00e9rer l'allocation de la RAM entre les diff\u00e9rents programmes pouvant s'ex\u00e9cuter. Comme la m\u00e9moire physique est souvent trop petite pour contenir la totalit\u00e9 des programmes, la gestion de la m\u00e9moire se fait selon le principe de la m\u00e9moire virtuelle. A un instant donn\u00e9, seules sont charg\u00e9es en RAM les parties de code et donn\u00e9es utiles \u00e0 l'ex\u00e9cution. Ainsi, chacun des processus acc\u00e8de \u00e0 toute la m\u00e9moire \u00e0 un instant T. A cela on ajoute le m\u00e9canisme de SWAP qui permet de d\u00e9sengorger le syst\u00e8me en d\u00e9pla\u00e7ant des modules executables sur la m\u00e9moire secondaire (le HDD). C'est plus lent, mais au moins le syst\u00e8me continue de fonctionner !","title":"Gestion de la m\u00e9moire"},{"location":"00_intro/#gestion-des-entreessorties","text":"Le syst\u00e8me doit g\u00e9rer l'acc\u00e8s aux p\u00e9riph\u00e9riques, c'est-\u00e0-dire faire la liaison entre les appels de haut niveau des programmes utilisateurs (exemple getchar()) et les op\u00e9rations de bas niveau de l\u2018unit\u00e9 d\u2019ex\u00e9cution responsable du p\u00e9riph\u00e9rique (UE clavier) C'est le pilote d'entr\u00e9es/sorties (driver) qui assure cette correspondance.","title":"Gestion des entr\u00e9es/sorties"},{"location":"00_intro/#gestion-des-objets-externes","text":"La m\u00e9moire centrale est une m\u00e9moire volatile (RAM). Aussi, toutes les donn\u00e9es devant \u00eatre conserv\u00e9es au del\u00e0 de l'arr\u00eat de la machine, doivent \u00eatre stock\u00e9es sur une m\u00e9moire de masse ( disque dur ).","title":"Gestion des objets externes"},{"location":"00_intro/#gestion-de-lacces-au-reseau","text":"Le syst\u00e8me doit permettre \u00e0 des ex\u00e9cutions de programmes, plac\u00e9es sur des machines distinctes, de communiquer. Le syst\u00e8me offre des outils de type socket pour acc\u00e9der \u00e0 la couche de protocoles de communication.","title":"Gestion de l\u2019acc\u00e8s au r\u00e9seau"},{"location":"00_intro/#gestion-de-la-protection","text":"Le syst\u00e8me doit fournir des m\u00e9canismes garantissant que ses ressources (CPU, m\u00e9moire, fichiers,\u2026) ne peuvent \u00eatre utilis\u00e9es que par les programmes auxquels les droits n\u00e9cessaires ont \u00e9t\u00e9 accord\u00e9s. Syst\u00e8mes TR : Les programmes en ex\u00e9cution sont soumis \u00e0 des contraintes de temps fortes, c'est-\u00e0-dire que leurs ex\u00e9cutions doivent \u00eatre imp\u00e9rativement achev\u00e9es \u00e0 une date butoir appel\u00e9e \u00e9ch\u00e9ance (Robotique / S\u00e9curit\u00e9 / D\u00e9fense) \u21a9","title":"Gestion de la protection"},{"location":"01_history/","text":"Histoire \u00b6 1940 : Traitement en S\u00e9rie \u00b6 Un programmeur \u00e0 la fois, un programme \u00e0 la fois. Nec\u00e9ssite l'intervention humaine pour changer de programme. 1950 : Traitement par Lots \u00b6 Introduction d'un programme montiteur , qui serveille les taches en cours et permet d'enchainer automatiquement une liste de taches. Chaque utilisateur soumet ses t\u00e2ches \u00e0 l\u2019op\u00e9rateur de l\u2019ordinateur : cartes perfor\u00e9es, rubans magn\u00e9tiques Il ya un regroupement des t\u00e2ches Puis ex\u00e9cution s\u00e9quentielle des regroupements La fin d\u2019une t\u00e2che est suivie par un branchement vers le moniteur. Le Moniteur charge en m\u00e9moire la t\u00e2che suivante et l\u2019ex\u00e9cute dans le processeur L\u2019ordinateur est soit en ex\u00e9cution d\u2019un programme utilisateur soit en ex\u00e9cution du programme moniteur 1950- 1960 : Traitement par Lots Multiprogramm\u00e9s \u00b6 L'am\u00e9lioration logique consite \u00e0 ex\u00e9cuter une autre t\u00e2che dans les portions de temps o\u00f9 le processeur est inactif. Ceci exige la coop\u00e9ration du mat\u00e9riel. Apparition des interruptions mat\u00e9rielles & Module de gestion des interruptions : Transfert rapide des donn\u00e9es sans intervention du processeur. Cr\u00e9ation d\u2019un module de Memory Management : maintenir en m\u00e9moire les t\u00e2ches pour l\u2019ex\u00e9cution. Cr\u00e9ation d\u2019un module d\u2019ordonnancement des t\u00e2ches : permet d\u2019avoir plus d\u2019une t\u00e2che en m\u00e9moire, s\u00e9lectionne l\u2019une des t\u00e2ches pour l\u2019ex\u00e9cution. Important ! Traitement par lots = pas d\u2019interactivit\u00e9 ! D\u00e9but 1960 : Traitement en Temps Partag\u00e9 \u00b6 Une nouvelle technique doit \u00eatre d\u00e9velopp\u00e9e: le CTSS (Compatible Time-Sharing System) de MIT. Blocage / Red\u00e9marrage p\u00e9riodique des t\u00e2ches \u00e0 l\u2019aide d\u2019une interruption cadenc\u00e9e par une source stable (CLK). Chaque utilisateur du syst\u00e8me est reli\u00e9 \u00e0 l\u2019ordinateur par le biais d\u2019un terminal. Utilisateur = terminal = t\u00e2che Important ! Le processeur est contr\u00f4l\u00e9 par chaque terminal durant une br\u00e8ve p\u00e9riode de temps. Ainsi, les t\u00e2ches ont tour \u00e0 tour l\u2019attention du processeur ( round-robin ). Lorsqu\u2019une t\u00e2che est en attente d\u2019une op\u00e9ration E/S : elle est imm\u00e9diatement bloqu\u00e9e le contr\u00f4le du processeur est pass\u00e9 \u00e0 une autre t\u00e2che Multi Programming Temps Partag\u00e9 Objectif Maximiser l'utilisation du processeur Minimiser le Temps de R\u00e9ponse Source des Commandes Job Control Language (JCL) Commandes interactives via le Terminal 1965 ~ : Multi-t\u00e2ches et multi-utilisateur \u00b6 Success Association du Multi-tache (multi-programmation) + Multi-Utilisateur (temps partag\u00e9) : MULTICS. En ajoutant un Syst\u00e8me de Gestion de Fichiers (SGF) , on a d\u00e9j\u00e0 la structure d'un SE Moderne ! Pour r\u00e9sumer en Vid\u00e9o \u00b6","title":"Histoire"},{"location":"01_history/#histoire","text":"","title":"Histoire"},{"location":"01_history/#1940-traitement-en-serie","text":"Un programmeur \u00e0 la fois, un programme \u00e0 la fois. Nec\u00e9ssite l'intervention humaine pour changer de programme.","title":"1940 : Traitement en S\u00e9rie"},{"location":"01_history/#1950-traitement-par-lots","text":"Introduction d'un programme montiteur , qui serveille les taches en cours et permet d'enchainer automatiquement une liste de taches. Chaque utilisateur soumet ses t\u00e2ches \u00e0 l\u2019op\u00e9rateur de l\u2019ordinateur : cartes perfor\u00e9es, rubans magn\u00e9tiques Il ya un regroupement des t\u00e2ches Puis ex\u00e9cution s\u00e9quentielle des regroupements La fin d\u2019une t\u00e2che est suivie par un branchement vers le moniteur. Le Moniteur charge en m\u00e9moire la t\u00e2che suivante et l\u2019ex\u00e9cute dans le processeur L\u2019ordinateur est soit en ex\u00e9cution d\u2019un programme utilisateur soit en ex\u00e9cution du programme moniteur","title":"1950 : Traitement par Lots"},{"location":"01_history/#1950-1960-traitement-par-lots-multiprogrammes","text":"L'am\u00e9lioration logique consite \u00e0 ex\u00e9cuter une autre t\u00e2che dans les portions de temps o\u00f9 le processeur est inactif. Ceci exige la coop\u00e9ration du mat\u00e9riel. Apparition des interruptions mat\u00e9rielles & Module de gestion des interruptions : Transfert rapide des donn\u00e9es sans intervention du processeur. Cr\u00e9ation d\u2019un module de Memory Management : maintenir en m\u00e9moire les t\u00e2ches pour l\u2019ex\u00e9cution. Cr\u00e9ation d\u2019un module d\u2019ordonnancement des t\u00e2ches : permet d\u2019avoir plus d\u2019une t\u00e2che en m\u00e9moire, s\u00e9lectionne l\u2019une des t\u00e2ches pour l\u2019ex\u00e9cution. Important ! Traitement par lots = pas d\u2019interactivit\u00e9 !","title":"1950- 1960 : Traitement par Lots Multiprogramm\u00e9s"},{"location":"01_history/#debut-1960-traitement-en-temps-partage","text":"Une nouvelle technique doit \u00eatre d\u00e9velopp\u00e9e: le CTSS (Compatible Time-Sharing System) de MIT. Blocage / Red\u00e9marrage p\u00e9riodique des t\u00e2ches \u00e0 l\u2019aide d\u2019une interruption cadenc\u00e9e par une source stable (CLK). Chaque utilisateur du syst\u00e8me est reli\u00e9 \u00e0 l\u2019ordinateur par le biais d\u2019un terminal. Utilisateur = terminal = t\u00e2che Important ! Le processeur est contr\u00f4l\u00e9 par chaque terminal durant une br\u00e8ve p\u00e9riode de temps. Ainsi, les t\u00e2ches ont tour \u00e0 tour l\u2019attention du processeur ( round-robin ). Lorsqu\u2019une t\u00e2che est en attente d\u2019une op\u00e9ration E/S : elle est imm\u00e9diatement bloqu\u00e9e le contr\u00f4le du processeur est pass\u00e9 \u00e0 une autre t\u00e2che Multi Programming Temps Partag\u00e9 Objectif Maximiser l'utilisation du processeur Minimiser le Temps de R\u00e9ponse Source des Commandes Job Control Language (JCL) Commandes interactives via le Terminal","title":"D\u00e9but 1960 : Traitement en Temps Partag\u00e9"},{"location":"01_history/#1965-multi-taches-et-multi-utilisateur","text":"Success Association du Multi-tache (multi-programmation) + Multi-Utilisateur (temps partag\u00e9) : MULTICS. En ajoutant un Syst\u00e8me de Gestion de Fichiers (SGF) , on a d\u00e9j\u00e0 la structure d'un SE Moderne !","title":"1965 ~ : Multi-t\u00e2ches et multi-utilisateur"},{"location":"01_history/#pour-resumer-en-video","text":"","title":"Pour r\u00e9sumer en Vid\u00e9o"},{"location":"02_sgf/","text":"Le Syst\u00e8me de Gestion de Fichiers \u00b6 Pourquoi ? \u00b6 On ne peut pas stocker d'informations de mani\u00e8re durable dans la RAM puisqu'elle est volatile, et de taille restreinte. Il faut donc organiser nos donn\u00e9es qui doivent perdurer sur le Disque Dur, afin de pouvoir stocker de gros volumes, de pouvoir les partager etc ... Le SGF d\u00e9finit : organisation coh\u00e9rente de la m\u00e9moire secondaire Notion de fichiers et de r\u00e9pertoires Les sous-r\u00e9pertoire sont des enfants d\u2019un r\u00e9pertoire racine On a donc un hierarchie , o\u00f9 un r\u00e9pertoire peut en contenir d\u2019autres. comment nommer les fichiers (carcat\u00e8res interdits, r\u00e9serv\u00e9s, extensions etc ...)? comment les structurer ? comment les utiliser, les prot\u00e9ger ? Important ! Sur un syst\u00e8me UNIX : l'OS g\u00e8re un fichier et un dossier de la m\u00eame mani\u00e8re ! Un dossier est un fichier qui peut en contenir d'autres. Un fichier simple est un fichier qui ne peut pas en contenir d'autres. La distinction ne tient qu'\u00e0 un attribu qui indique que le fichier en question est en fait un dossier. Inodes \u00b6 Le SGF conserve une liste de tous les fichiers : la table des inodes. Un inodes est un n\u0153uds d\u2019information qui contient les attributs d'un fichier (jusqu'\u00e0 40+ sur certains OS !) : type de fichier (fichier simple, repertoire, socket ...) propri\u00e9taire (user, group) permissions compteur de lien : nb de r\u00e9pertoires contenant une entr\u00e9e avec ce num\u00e9ro d\u2019inode marques temporelles (date/heure cr\u00e9ation, date/heure modification) liste de blocs (liste des n\u00b0 de blocs contenant le 1er segment du fichier) ... Important ! Un inode ne contient PAS le nom du fichier. Un fichier simple \u00e9tant forc\u00e9ment dans un fichier de type r\u00e9pertoire, c'est le fichier r\u00e9pertoire qui contient les noms des fichiers qu'il contient ! Cela permet d'avoir une table d'inodes de petite dimension, qui se parcourt rapidement ! Types des fichiers \u00b6 Tip On peut facilement voir le type d'un fichier en faisant la command ls -l qui affiche le nom du fichier pr\u00e9c\u00e9d\u00e9 des son type et droits d'acc\u00e8s : 1 2 3 4 5 ls -l l rw-r--r-- 1 jberger 1049089 309 Oct 29 10 :06 monLien -> SE/TP2/src/bonjour.c - rw-r--r-- 1 jberger 1049089 16 Oct 29 10 :36 testRegexp d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP1/ d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP2/ Fichiers normaux : \u00b6 Utilis\u00e9s par les users Fichiers ASCII : lignes de texte (caract\u00e8re \u00ab fin de ligne \u00bb variable selon les SE) avantage = facilement lisibles et modifiables Fichiers binaires : structur\u00e9s pour que l \u2019on puisse retrouver ses informations. R\u00e9pertoires : \u00b6 Utilis\u00e9s par les users Fichiers de type particulier qui contiennent une liste d\u2019autres fichiers Lien permanent : \u00b6 Entr\u00e9e de r\u00e9pertoire normale qui au lieu de pointer vers un fichier unique, pointe sur un fichier d\u00e9j\u00e0 existant. Permet de donner plusieurs noms \u00e0 un fichier, dans des r\u00e9pertoires diff\u00e9rents. Donc de le partager ! Ce fichier ne sera effac\u00e9 que lorsque son dernier nom est supprim\u00e9 (pas d\u2019inode suppl\u00e9mentaire). Lien symbolique : \u00b6 Ne pointe pas vers un autre inode comme un lien permanent mais vers un autre nom de fichier (inode suppl\u00e9mentaire). Lors d'un parcours automatique de disque, on passera plusieurs fois au meme endroit de la m\u00e9moir vu qu'il y a une nouvelle inode ... Peut perf ! Diff\u00e9rence en image : Socket : \u00b6 Moyen de communication avec d\u2019autre machines via le r\u00e9seau. Pipes nomm\u00e9s : \u00b6 Moyen de communication entre processus d'une m\u00eame machine. Fichiers sp\u00e9ciaux caract\u00e8res : \u00b6 Offre un m\u00e9canisme de communication avec les pilotes de p\u00e9riph\u00e9riques \u00e0 raison d\u2019un caract\u00e8re \u00e0 la fois. Mod\u00e9lisation d\u2019E/S (terminaux,imprimante ...) (Contenu non gard\u00e9 en m\u00e9moire). Fichiers sp\u00e9ciaux bloc : \u00b6 Offre un m\u00e9canisme de communication avec les pilotes de p\u00e9riph\u00e9riques, similitude avec les fichiers sp\u00e9ciaux \u00e0 caract\u00e8res, mais avec une quantit\u00e9 de donn\u00e9es plus importante. Mod\u00e9lisation des disques (Contenu gard\u00e9 en m\u00e9moire). Permissions sur les Fichiers \u00b6 D\u00e9finition des Droits \u00b6 Un fichier peut appartenir \u00e0 un utilisateur qui lui-m\u00eame fait partie d'un ensemble d'utilisateur ( groupe ) qui ont tous les m\u00eames droits sur une m\u00eame machine. Par example, il peut y avoir un groupe \u00e9l\u00e8ves et profs sur une m\u00eame machine et les \u00e9l\u00e8ves connect\u00e9s n'ont pas acc\u00e8s aux fichiers de correction ! On va donc g\u00e9rer les acc\u00e8s pour : Un User Un Groupe d'Users Les Autres Tip On peut facilement voir les droits d'acc\u00e8s \u00e0 un fichier en faisant la command ls -l 1 2 3 4 5 ls -l l rw-r--r-- 1 jberger 1049089 309 Oct 29 10 :06 monLien -> SE/TP2/src/bonjour.c - rw-r--r-- 1 jberger 1049089 16 Oct 29 10 :36 testRegexp d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP1/ d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP2/ Ici, l'utilisateur jberger en particulier peut lire et ecrire le fichier testRegexp . Les utilisateurs appartenant au groupe 1049089 peuvent uniquement le lire. Idem pour tous les autres utilisateurs. Modification des Droits \u00b6 Le codage des droits est fait sous forme binaire (en puissances de 2), pour chaque bloc de permissions (user/group/others). Ainsi le codage des droits rwxr-x--- donne 750 : - Droits User : \\(2^2 + 2^1 + 2^0 = 7\\) - Droits Groupe : \\(2^2 + 0 + 2^0 = 5\\) - Droits Autres : \\(0 + 0 + 0 = 0\\) Tip Pour modifier les droits, il existe la commande chmod . Elle permet de modifier avec la notation binaire, mais aussi en changent juste certains bits sur un set de droits : chmod 750 toto.txt chmod u+rwx,g+rx,o-rwx toto.txt Avec la deuxieme notations, les bits non mentionn\u00e9s ne sont pas chang\u00e9s !! Hi\u00e9rarchie \u00b6 On a un syst\u00e8me de catalogues : m\u00e9morisation des noms, attributs et adresses des fichiers. La structure courante est une arborescence de catalogues . Un chemin d\u2019acc\u00e8s est le moyen d'arriver \u00e0 un fichier situ\u00e9 dans cet arbre. Chemin absolu = \u00e0 partir de la racine de l\u2019arbre (ROOT) Chemin relatif = \u00e0 partir de la position courante dans l\u2019arbre Chemin non lin\u00e9aire = permet de couper l'arborescence en suivant un lien Dans les SE UNIX Based : . = catalogue courant .. = catalogue p\u00e8re ~ = r\u00e9pertoir d ebase d'un utilisateur Op\u00e9rations sur les Fichiers \u00b6 Ces op\u00e9rations se font gr\u00e2ce \u00e0 des appels syst\u00e8mes (fonction disponibles dans le noyau) : CREATE (cr\u00e9ation d\u2019un fichier vide) DELETE OPEN CLOSE READ (lecture de n octets \u00e0 partir de la position courante) WRITE APPEND (\u00e9criture en fin de fichier) SEEK (indication de la position des donn\u00e9es \u00e0 lire/\u00e9crire) GET ATTRIBUTES SET ATTRIBUTES RENAME Stockage des fichiers \u00b6 Comment le SE sauve-t-il le fichier sur le disque ? Allocation contigu\u00eb : \u00b6 Tous les blocs se suivent m\u00e9thode la plus simple mais co\u00fbteuse en espace disque Allocation \u00abliste cha\u00een\u00e9e\u00bb : \u00b6 Chaque bloc contient l\u2019adresse du bloc suivant pas d\u2019espace perdu mais acc\u00e8s al\u00e9atoire lent Allocation \u00abliste cha\u00een\u00e9e index\u00e9e\u00bb : \u00b6 Regroupement des \u00abadresses de bloc\u00bb dans une table (index) en m\u00e9moire [MS-DOS] inconv\u00e9nient : table enti\u00e8rement en m\u00e9moire ...","title":"SGF"},{"location":"02_sgf/#le-systeme-de-gestion-de-fichiers","text":"","title":"Le Syst\u00e8me de Gestion de Fichiers"},{"location":"02_sgf/#pourquoi","text":"On ne peut pas stocker d'informations de mani\u00e8re durable dans la RAM puisqu'elle est volatile, et de taille restreinte. Il faut donc organiser nos donn\u00e9es qui doivent perdurer sur le Disque Dur, afin de pouvoir stocker de gros volumes, de pouvoir les partager etc ... Le SGF d\u00e9finit : organisation coh\u00e9rente de la m\u00e9moire secondaire Notion de fichiers et de r\u00e9pertoires Les sous-r\u00e9pertoire sont des enfants d\u2019un r\u00e9pertoire racine On a donc un hierarchie , o\u00f9 un r\u00e9pertoire peut en contenir d\u2019autres. comment nommer les fichiers (carcat\u00e8res interdits, r\u00e9serv\u00e9s, extensions etc ...)? comment les structurer ? comment les utiliser, les prot\u00e9ger ? Important ! Sur un syst\u00e8me UNIX : l'OS g\u00e8re un fichier et un dossier de la m\u00eame mani\u00e8re ! Un dossier est un fichier qui peut en contenir d'autres. Un fichier simple est un fichier qui ne peut pas en contenir d'autres. La distinction ne tient qu'\u00e0 un attribu qui indique que le fichier en question est en fait un dossier.","title":"Pourquoi ?"},{"location":"02_sgf/#inodes","text":"Le SGF conserve une liste de tous les fichiers : la table des inodes. Un inodes est un n\u0153uds d\u2019information qui contient les attributs d'un fichier (jusqu'\u00e0 40+ sur certains OS !) : type de fichier (fichier simple, repertoire, socket ...) propri\u00e9taire (user, group) permissions compteur de lien : nb de r\u00e9pertoires contenant une entr\u00e9e avec ce num\u00e9ro d\u2019inode marques temporelles (date/heure cr\u00e9ation, date/heure modification) liste de blocs (liste des n\u00b0 de blocs contenant le 1er segment du fichier) ... Important ! Un inode ne contient PAS le nom du fichier. Un fichier simple \u00e9tant forc\u00e9ment dans un fichier de type r\u00e9pertoire, c'est le fichier r\u00e9pertoire qui contient les noms des fichiers qu'il contient ! Cela permet d'avoir une table d'inodes de petite dimension, qui se parcourt rapidement !","title":"Inodes"},{"location":"02_sgf/#types-des-fichiers","text":"Tip On peut facilement voir le type d'un fichier en faisant la command ls -l qui affiche le nom du fichier pr\u00e9c\u00e9d\u00e9 des son type et droits d'acc\u00e8s : 1 2 3 4 5 ls -l l rw-r--r-- 1 jberger 1049089 309 Oct 29 10 :06 monLien -> SE/TP2/src/bonjour.c - rw-r--r-- 1 jberger 1049089 16 Oct 29 10 :36 testRegexp d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP1/ d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP2/","title":"Types des fichiers"},{"location":"02_sgf/#fichiers-normaux","text":"Utilis\u00e9s par les users Fichiers ASCII : lignes de texte (caract\u00e8re \u00ab fin de ligne \u00bb variable selon les SE) avantage = facilement lisibles et modifiables Fichiers binaires : structur\u00e9s pour que l \u2019on puisse retrouver ses informations.","title":"Fichiers normaux :"},{"location":"02_sgf/#repertoires","text":"Utilis\u00e9s par les users Fichiers de type particulier qui contiennent une liste d\u2019autres fichiers","title":"R\u00e9pertoires :"},{"location":"02_sgf/#lien-permanent","text":"Entr\u00e9e de r\u00e9pertoire normale qui au lieu de pointer vers un fichier unique, pointe sur un fichier d\u00e9j\u00e0 existant. Permet de donner plusieurs noms \u00e0 un fichier, dans des r\u00e9pertoires diff\u00e9rents. Donc de le partager ! Ce fichier ne sera effac\u00e9 que lorsque son dernier nom est supprim\u00e9 (pas d\u2019inode suppl\u00e9mentaire).","title":"Lien permanent :"},{"location":"02_sgf/#lien-symbolique","text":"Ne pointe pas vers un autre inode comme un lien permanent mais vers un autre nom de fichier (inode suppl\u00e9mentaire). Lors d'un parcours automatique de disque, on passera plusieurs fois au meme endroit de la m\u00e9moir vu qu'il y a une nouvelle inode ... Peut perf ! Diff\u00e9rence en image :","title":"Lien symbolique :"},{"location":"02_sgf/#socket","text":"Moyen de communication avec d\u2019autre machines via le r\u00e9seau.","title":"Socket :"},{"location":"02_sgf/#pipes-nommes","text":"Moyen de communication entre processus d'une m\u00eame machine.","title":"Pipes nomm\u00e9s :"},{"location":"02_sgf/#fichiers-speciaux-caracteres","text":"Offre un m\u00e9canisme de communication avec les pilotes de p\u00e9riph\u00e9riques \u00e0 raison d\u2019un caract\u00e8re \u00e0 la fois. Mod\u00e9lisation d\u2019E/S (terminaux,imprimante ...) (Contenu non gard\u00e9 en m\u00e9moire).","title":"Fichiers sp\u00e9ciaux caract\u00e8res :"},{"location":"02_sgf/#fichiers-speciaux-bloc","text":"Offre un m\u00e9canisme de communication avec les pilotes de p\u00e9riph\u00e9riques, similitude avec les fichiers sp\u00e9ciaux \u00e0 caract\u00e8res, mais avec une quantit\u00e9 de donn\u00e9es plus importante. Mod\u00e9lisation des disques (Contenu gard\u00e9 en m\u00e9moire).","title":"Fichiers sp\u00e9ciaux bloc :"},{"location":"02_sgf/#permissions-sur-les-fichiers","text":"","title":"Permissions sur les Fichiers"},{"location":"02_sgf/#definition-des-droits","text":"Un fichier peut appartenir \u00e0 un utilisateur qui lui-m\u00eame fait partie d'un ensemble d'utilisateur ( groupe ) qui ont tous les m\u00eames droits sur une m\u00eame machine. Par example, il peut y avoir un groupe \u00e9l\u00e8ves et profs sur une m\u00eame machine et les \u00e9l\u00e8ves connect\u00e9s n'ont pas acc\u00e8s aux fichiers de correction ! On va donc g\u00e9rer les acc\u00e8s pour : Un User Un Groupe d'Users Les Autres Tip On peut facilement voir les droits d'acc\u00e8s \u00e0 un fichier en faisant la command ls -l 1 2 3 4 5 ls -l l rw-r--r-- 1 jberger 1049089 309 Oct 29 10 :06 monLien -> SE/TP2/src/bonjour.c - rw-r--r-- 1 jberger 1049089 16 Oct 29 10 :36 testRegexp d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP1/ d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP2/ Ici, l'utilisateur jberger en particulier peut lire et ecrire le fichier testRegexp . Les utilisateurs appartenant au groupe 1049089 peuvent uniquement le lire. Idem pour tous les autres utilisateurs.","title":"D\u00e9finition des Droits"},{"location":"02_sgf/#modification-des-droits","text":"Le codage des droits est fait sous forme binaire (en puissances de 2), pour chaque bloc de permissions (user/group/others). Ainsi le codage des droits rwxr-x--- donne 750 : - Droits User : \\(2^2 + 2^1 + 2^0 = 7\\) - Droits Groupe : \\(2^2 + 0 + 2^0 = 5\\) - Droits Autres : \\(0 + 0 + 0 = 0\\) Tip Pour modifier les droits, il existe la commande chmod . Elle permet de modifier avec la notation binaire, mais aussi en changent juste certains bits sur un set de droits : chmod 750 toto.txt chmod u+rwx,g+rx,o-rwx toto.txt Avec la deuxieme notations, les bits non mentionn\u00e9s ne sont pas chang\u00e9s !!","title":"Modification des Droits"},{"location":"02_sgf/#hierarchie","text":"On a un syst\u00e8me de catalogues : m\u00e9morisation des noms, attributs et adresses des fichiers. La structure courante est une arborescence de catalogues . Un chemin d\u2019acc\u00e8s est le moyen d'arriver \u00e0 un fichier situ\u00e9 dans cet arbre. Chemin absolu = \u00e0 partir de la racine de l\u2019arbre (ROOT) Chemin relatif = \u00e0 partir de la position courante dans l\u2019arbre Chemin non lin\u00e9aire = permet de couper l'arborescence en suivant un lien Dans les SE UNIX Based : . = catalogue courant .. = catalogue p\u00e8re ~ = r\u00e9pertoir d ebase d'un utilisateur","title":"Hi\u00e9rarchie"},{"location":"02_sgf/#operations-sur-les-fichiers","text":"Ces op\u00e9rations se font gr\u00e2ce \u00e0 des appels syst\u00e8mes (fonction disponibles dans le noyau) : CREATE (cr\u00e9ation d\u2019un fichier vide) DELETE OPEN CLOSE READ (lecture de n octets \u00e0 partir de la position courante) WRITE APPEND (\u00e9criture en fin de fichier) SEEK (indication de la position des donn\u00e9es \u00e0 lire/\u00e9crire) GET ATTRIBUTES SET ATTRIBUTES RENAME","title":"Op\u00e9rations sur les Fichiers"},{"location":"02_sgf/#stockage-des-fichiers","text":"Comment le SE sauve-t-il le fichier sur le disque ?","title":"Stockage des fichiers"},{"location":"02_sgf/#allocation-contigue","text":"Tous les blocs se suivent m\u00e9thode la plus simple mais co\u00fbteuse en espace disque","title":"Allocation contigu\u00eb :"},{"location":"02_sgf/#allocation-liste-chainee","text":"Chaque bloc contient l\u2019adresse du bloc suivant pas d\u2019espace perdu mais acc\u00e8s al\u00e9atoire lent","title":"Allocation \u00abliste cha\u00een\u00e9e\u00bb :"},{"location":"02_sgf/#allocation-liste-chainee-indexee","text":"Regroupement des \u00abadresses de bloc\u00bb dans une table (index) en m\u00e9moire [MS-DOS] inconv\u00e9nient : table enti\u00e8rement en m\u00e9moire ...","title":"Allocation \u00abliste cha\u00een\u00e9e index\u00e9e\u00bb :"},{"location":"03_processus/","text":"Processus \u00b6 D\u00e9finition \u00b6 Un processus : Est un programme en cours d'execution. C'est donc une entit\u00e9 dynamique ! Cela implique qu'il a un cycle de vie avec une naissance et une mort, mais aussi qu'il peut interagir avec d'autres processus ! Interagit par communication En utilisant le syst\u00e8me de communication inter-processus (m\u00e9moire partag\u00e9e, tuyaux/pipes, files de messages, etc.) du SE. Utilise des ressources Ces ressources sont des : fichiers, m\u00e9moire, s\u00e9maphores p\u00e9riph\u00e9riques d\u2019E/S, etc. Ces ressources sont contr\u00f4l\u00e9es par le S.E. Poss\u00e8de un context qui lui est propre Un environnement processeur & un environnement m\u00e9moire. Est toujours lanc\u00e9 par un processus parent existant. Poss\u00e8de un num\u00e9ro unique (PID) Cycle de vie \u00b6 Tip A la place de \"En Execution\" on parlera aussi de processus \"Elu\" A un instant donn\u00e9, un processus peut \u00eatre dans l\u2019un des \u00e9tats suivants : Actif/Elu : le processus s\u2019ex\u00e9cute sur un processeur (il n\u2019y a donc qu\u2019un seul processus actif en m\u00eame temps sur une machine monoprocesseur) Pr\u00eat : le processus peut devenir actif d\u00e8s que le processeur lui sera attribu\u00e9 par le syst\u00e8me Bloqu\u00e9 : le processus a besoin d\u2019une ressource pour continuer (attente d\u2019entr\u00e9e/sortie par exemple). Le blocage ne peut avoir lieu qu\u2019\u00e0 la suite d\u2019un appel syst\u00e8me. Un processus bloqu\u00e9 ne consomme pas de temps processeur. Il peut y en avoir beaucoup sans p\u00e9naliser les performances du syst\u00e8me. Warning Si un processus ne respecte pas son cycle de vie, il terminera dans un \u00e9tat \" ZOMBIE \", tr\u00e8s n\u00e9faste pour la machine h\u00f4te ... Cycle de vie simplifi\u00e9 \u00b6 Communcication Inter Processus \u00b6 La communication inter-process est essentielle car elle permet : Le transfert des donn\u00e9es entre processus Via des \"pipes\", \"memory sharing\", \"message queue\" ou des \"signaux\" Nous nous interesserons particuli\u00e8rement aux Pipes : Structure de donn\u00e9es FIFO dont les acc\u00e8s sont g\u00e9r\u00e9s par le S.E La coordination des processus M\u00e9thodes qui \u00e9vitent les erreurs dans l\u2019acc\u00e8s des donn\u00e9es et leurs traitements La synchronisation des processus Appels de syst\u00e8me permettant l'ordonancement des processus Nous nous interesserons particuli\u00e8rement aux fonction signal() et wait() dans la partie programmation syst\u00e8me dee ce cours Les deux derniers points sont essentiels car ils permettent d'\u00e9viter : L'impasse Interd\u00e9pendance (de donn\u00e9es) des processus qui emp\u00eache la progression de tous les processus impliqu\u00e9s Analogie : arr\u00eat toutes directions \u00e0 l\u2019intersection des chemins crois\u00e9s La famine Interd\u00e9pendance (de donn\u00e9es) des processus qui emp\u00eache la progression d\u2019un sous-ensemble de processus impliqu\u00e9s Analogie : devant un tourniquet \u00e0 l\u2019entr\u00e9e d\u2019un m\u00e9tro \u00e0 l\u2019heure de pointe Table des Processus \u00b6 Elle form\u00e9e d\u2019un tableau de structures d\u00e9crivant les processus, dont le noyau se sert pour g\u00e9rer leur ex\u00e9cution. Chaque entr\u00e9e dans la table d\u00e9finit un processus cr\u00e9e par le noyau. Elle r\u00e9side en m\u00e9moire , le noyau l\u2019interroge et la met \u00e0 jour en permanence lorsqu\u2019il alloue et d\u00e9salloue du temps CPU aux processus. Les informations d\u2019ordonnancement de processus de cette table sont aussi mises \u00e0 jour pour les processus qui ne sont pas en cours d\u2019ex\u00e9cution. Important On parle de table ... ce qui implique que chaque processus poss\u00e8de identifiant unique appel\u00e9 PID (Process ID). Tip Les structures des processus sont d\u00e9finies dans /usr/include/sys/proc.h Context d'\u00e9xecution \u00b6 Pour pouvoir stopper et reprendre un processus o\u00f9 il en \u00e9tait, le SE doit g\u00e9rer et conserver/restaurer le context d'execution de chaque processus. Hierarchie \u00b6 Comme tout bon syst\u00e8me UNIX, et comme pour le SGF, la gestion des processus repose sur un concept arborescent . Modes d'\u00e9xecution \u00b6 Interactif (foreground) \u00b6 Le plus fr\u00e9quent (on tape une cmd, on attend un r\u00e9sultat) Interruption de la commande par CTRL^C Suspension de la commande par CTRL^Z Arri\u00e8re plan (background) \u00b6 La cmd est lanc\u00e9e, mais on rend le contr\u00f4le \u00e0 l\u2019utilisateur Pas d\u2019interaction avec l\u2019utilisateur. Conclusion \u00b6 Success Maintenant, votre point de vue de programmeur sur les OS doit ressembler \u00e0 ceci :","title":"Processus"},{"location":"03_processus/#processus","text":"","title":"Processus"},{"location":"03_processus/#definition","text":"Un processus : Est un programme en cours d'execution. C'est donc une entit\u00e9 dynamique ! Cela implique qu'il a un cycle de vie avec une naissance et une mort, mais aussi qu'il peut interagir avec d'autres processus ! Interagit par communication En utilisant le syst\u00e8me de communication inter-processus (m\u00e9moire partag\u00e9e, tuyaux/pipes, files de messages, etc.) du SE. Utilise des ressources Ces ressources sont des : fichiers, m\u00e9moire, s\u00e9maphores p\u00e9riph\u00e9riques d\u2019E/S, etc. Ces ressources sont contr\u00f4l\u00e9es par le S.E. Poss\u00e8de un context qui lui est propre Un environnement processeur & un environnement m\u00e9moire. Est toujours lanc\u00e9 par un processus parent existant. Poss\u00e8de un num\u00e9ro unique (PID)","title":"D\u00e9finition"},{"location":"03_processus/#cycle-de-vie","text":"Tip A la place de \"En Execution\" on parlera aussi de processus \"Elu\" A un instant donn\u00e9, un processus peut \u00eatre dans l\u2019un des \u00e9tats suivants : Actif/Elu : le processus s\u2019ex\u00e9cute sur un processeur (il n\u2019y a donc qu\u2019un seul processus actif en m\u00eame temps sur une machine monoprocesseur) Pr\u00eat : le processus peut devenir actif d\u00e8s que le processeur lui sera attribu\u00e9 par le syst\u00e8me Bloqu\u00e9 : le processus a besoin d\u2019une ressource pour continuer (attente d\u2019entr\u00e9e/sortie par exemple). Le blocage ne peut avoir lieu qu\u2019\u00e0 la suite d\u2019un appel syst\u00e8me. Un processus bloqu\u00e9 ne consomme pas de temps processeur. Il peut y en avoir beaucoup sans p\u00e9naliser les performances du syst\u00e8me. Warning Si un processus ne respecte pas son cycle de vie, il terminera dans un \u00e9tat \" ZOMBIE \", tr\u00e8s n\u00e9faste pour la machine h\u00f4te ...","title":"Cycle de vie"},{"location":"03_processus/#cycle-de-vie-simplifie","text":"","title":"Cycle de vie simplifi\u00e9"},{"location":"03_processus/#communcication-inter-processus","text":"La communication inter-process est essentielle car elle permet : Le transfert des donn\u00e9es entre processus Via des \"pipes\", \"memory sharing\", \"message queue\" ou des \"signaux\" Nous nous interesserons particuli\u00e8rement aux Pipes : Structure de donn\u00e9es FIFO dont les acc\u00e8s sont g\u00e9r\u00e9s par le S.E La coordination des processus M\u00e9thodes qui \u00e9vitent les erreurs dans l\u2019acc\u00e8s des donn\u00e9es et leurs traitements La synchronisation des processus Appels de syst\u00e8me permettant l'ordonancement des processus Nous nous interesserons particuli\u00e8rement aux fonction signal() et wait() dans la partie programmation syst\u00e8me dee ce cours Les deux derniers points sont essentiels car ils permettent d'\u00e9viter : L'impasse Interd\u00e9pendance (de donn\u00e9es) des processus qui emp\u00eache la progression de tous les processus impliqu\u00e9s Analogie : arr\u00eat toutes directions \u00e0 l\u2019intersection des chemins crois\u00e9s La famine Interd\u00e9pendance (de donn\u00e9es) des processus qui emp\u00eache la progression d\u2019un sous-ensemble de processus impliqu\u00e9s Analogie : devant un tourniquet \u00e0 l\u2019entr\u00e9e d\u2019un m\u00e9tro \u00e0 l\u2019heure de pointe","title":"Communcication Inter Processus"},{"location":"03_processus/#table-des-processus","text":"Elle form\u00e9e d\u2019un tableau de structures d\u00e9crivant les processus, dont le noyau se sert pour g\u00e9rer leur ex\u00e9cution. Chaque entr\u00e9e dans la table d\u00e9finit un processus cr\u00e9e par le noyau. Elle r\u00e9side en m\u00e9moire , le noyau l\u2019interroge et la met \u00e0 jour en permanence lorsqu\u2019il alloue et d\u00e9salloue du temps CPU aux processus. Les informations d\u2019ordonnancement de processus de cette table sont aussi mises \u00e0 jour pour les processus qui ne sont pas en cours d\u2019ex\u00e9cution. Important On parle de table ... ce qui implique que chaque processus poss\u00e8de identifiant unique appel\u00e9 PID (Process ID). Tip Les structures des processus sont d\u00e9finies dans /usr/include/sys/proc.h","title":"Table des Processus"},{"location":"03_processus/#context-dexecution","text":"Pour pouvoir stopper et reprendre un processus o\u00f9 il en \u00e9tait, le SE doit g\u00e9rer et conserver/restaurer le context d'execution de chaque processus.","title":"Context d'\u00e9xecution"},{"location":"03_processus/#hierarchie","text":"Comme tout bon syst\u00e8me UNIX, et comme pour le SGF, la gestion des processus repose sur un concept arborescent .","title":"Hierarchie"},{"location":"03_processus/#modes-dexecution","text":"","title":"Modes d'\u00e9xecution"},{"location":"03_processus/#interactif-foreground","text":"Le plus fr\u00e9quent (on tape une cmd, on attend un r\u00e9sultat) Interruption de la commande par CTRL^C Suspension de la commande par CTRL^Z","title":"Interactif (foreground)"},{"location":"03_processus/#arriere-plan-background","text":"La cmd est lanc\u00e9e, mais on rend le contr\u00f4le \u00e0 l\u2019utilisateur Pas d\u2019interaction avec l\u2019utilisateur.","title":"Arri\u00e8re plan (background)"},{"location":"03_processus/#conclusion","text":"Success Maintenant, votre point de vue de programmeur sur les OS doit ressembler \u00e0 ceci :","title":"Conclusion"},{"location":"04_ordonnancement/","text":"Ordonnancement \u00b6 Dans la vraie vie, plusieurs processus cohabitent et peuvent \u00eatre pr\u00eats \u00e0 \u00eatres ex\u00e9cut\u00e9s en m\u00eame temps. Le SE doit faire un choix (selon un algorithme d'ordonnancement) : \u00e9quit\u00e9 : chaque processus doit avoir du temps processeur efficacit\u00e9 : le processeur doit \u00eatre utilis\u00e9 \u00e0 100% temps de r\u00e9ponse : l 'utilisateur devant sa machine ne doit pas trop attendre temps d'attente : les processus doivent d\u00e9marrer le plus vite possible temps d'ex\u00e9cution : une s\u00e9quence d'instructions ne doit pas trop durer rendement : il faut faire le plus de choses en une heure R\u00e9quisition \u00b6 Il existe deux grandes familles d'ordonnacement : Ordonnancement sans r\u00e9quisition (ou non pr\u00e9emptif) \u00b6 Un processus est ex\u00e9cut\u00e9 jusqu'\u00e0 la fin (sauf si il se bloque lui m\u00eame). inefficace et dangereux (ex: ex\u00e9cution d'une boucle sans fin...) Ordonnancement avec r\u00e9quisition (ou pr\u00e9emptif) \u00b6 A chaque signal d'horloge, le SE reprend la main, d\u00e9cide si le processus courant doit c\u00e9der sa place, et \u00e9ventuellement donne le processeur \u00e0 un autre processus. Un processus perds le processeur s'il se bloque lui-m\u00eame. Il existe de nombreux algorithmes d'ordonnancement avec r\u00e9quisition. C'est le noyau qui d\u00e9clenche le passage de l'\u00e9tat Elu \u00e0 l'\u00e9tat Pr\u00eat lors d'une r\u00e9quisition. FIFO \u00b6 Warning On remarque que l'ordre de passage change la donne ... Priorit\u00e9s \u00b6 Chaque processus re\u00e7oit une priorit\u00e9, le processus de plus forte priorit\u00e9 est \u00e9lu avec ou sans r\u00e9quisition. Round Robin (RR) ou \"tourniquet\" \u00b6 D\u00e9finition d'un quantum = tranche de temps. Un processus \u00e9lu s'ex\u00e9cute au plus durant un quantum. A la fin du quantum, pr\u00e9emption et r\u00e9insertion en fin de file d'attente des processus pr\u00eats. Files de priorit\u00e9s \u00b6 On d\u00e9finit des priorit\u00e9s constantes multi niveaux avec ou sans extinction de priorit\u00e9. Chaque file est associ\u00e9e \u00e0 un quantum \u00e9ventuellement diff\u00e9rent. Sans extinction : \u00b6 Un processus garde toujours la m\u00eame priorit\u00e9. Avec extinction : \u00b6 La priorit\u00e9 d'un processus d\u00e9cro\u00eet en fonction de son utilisation de la CPU. SJF : Shortest Job First \u00b6 Le plus court d'abord.","title":"Ordonnancement"},{"location":"04_ordonnancement/#ordonnancement","text":"Dans la vraie vie, plusieurs processus cohabitent et peuvent \u00eatre pr\u00eats \u00e0 \u00eatres ex\u00e9cut\u00e9s en m\u00eame temps. Le SE doit faire un choix (selon un algorithme d'ordonnancement) : \u00e9quit\u00e9 : chaque processus doit avoir du temps processeur efficacit\u00e9 : le processeur doit \u00eatre utilis\u00e9 \u00e0 100% temps de r\u00e9ponse : l 'utilisateur devant sa machine ne doit pas trop attendre temps d'attente : les processus doivent d\u00e9marrer le plus vite possible temps d'ex\u00e9cution : une s\u00e9quence d'instructions ne doit pas trop durer rendement : il faut faire le plus de choses en une heure","title":"Ordonnancement"},{"location":"04_ordonnancement/#requisition","text":"Il existe deux grandes familles d'ordonnacement :","title":"R\u00e9quisition"},{"location":"04_ordonnancement/#ordonnancement-sans-requisition-ou-non-preemptif","text":"Un processus est ex\u00e9cut\u00e9 jusqu'\u00e0 la fin (sauf si il se bloque lui m\u00eame). inefficace et dangereux (ex: ex\u00e9cution d'une boucle sans fin...)","title":"Ordonnancement sans r\u00e9quisition (ou non pr\u00e9emptif)"},{"location":"04_ordonnancement/#ordonnancement-avec-requisition-ou-preemptif","text":"A chaque signal d'horloge, le SE reprend la main, d\u00e9cide si le processus courant doit c\u00e9der sa place, et \u00e9ventuellement donne le processeur \u00e0 un autre processus. Un processus perds le processeur s'il se bloque lui-m\u00eame. Il existe de nombreux algorithmes d'ordonnancement avec r\u00e9quisition. C'est le noyau qui d\u00e9clenche le passage de l'\u00e9tat Elu \u00e0 l'\u00e9tat Pr\u00eat lors d'une r\u00e9quisition.","title":"Ordonnancement avec r\u00e9quisition (ou pr\u00e9emptif)"},{"location":"04_ordonnancement/#fifo","text":"Warning On remarque que l'ordre de passage change la donne ...","title":"FIFO"},{"location":"04_ordonnancement/#priorites","text":"Chaque processus re\u00e7oit une priorit\u00e9, le processus de plus forte priorit\u00e9 est \u00e9lu avec ou sans r\u00e9quisition.","title":"Priorit\u00e9s"},{"location":"04_ordonnancement/#round-robin-rr-ou-tourniquet","text":"D\u00e9finition d'un quantum = tranche de temps. Un processus \u00e9lu s'ex\u00e9cute au plus durant un quantum. A la fin du quantum, pr\u00e9emption et r\u00e9insertion en fin de file d'attente des processus pr\u00eats.","title":"Round Robin (RR) ou \"tourniquet\""},{"location":"04_ordonnancement/#files-de-priorites","text":"On d\u00e9finit des priorit\u00e9s constantes multi niveaux avec ou sans extinction de priorit\u00e9. Chaque file est associ\u00e9e \u00e0 un quantum \u00e9ventuellement diff\u00e9rent.","title":"Files de priorit\u00e9s"},{"location":"04_ordonnancement/#sans-extinction","text":"Un processus garde toujours la m\u00eame priorit\u00e9.","title":"Sans extinction :"},{"location":"04_ordonnancement/#avec-extinction","text":"La priorit\u00e9 d'un processus d\u00e9cro\u00eet en fonction de son utilisation de la CPU.","title":"Avec extinction :"},{"location":"04_ordonnancement/#sjf-shortest-job-first","text":"Le plus court d'abord.","title":"SJF : Shortest Job First"},{"location":"05_tdOrdo/","text":"TD Ordonnancement \u00b6 Objectifs \u00b6 Comparaison basique de deux syst\u00e8mes d'exploitation (Windows et Linux). Se rendre compte du travail effectu\u00e9 par le CPU : Ordonnancement manuel de processus. Pr\u00e9requis \u00b6 T\u00e9l\u00e9charger ce fichier BlankTables.xls pour noter vos r\u00e9sultats des exos 2 & 3 Exercice 1 : Comparatif rapide \u00b6 Un syst\u00e8me d'exploitation peut \u00eatre vu comme un ensemble de logiciels organis\u00e9s en couches, entre l'utilisateur et la partie mat\u00e9rielle de l'ordinateur. Vous avez a disposition des machine sous Windows et sous Linux ou Mac (la votre, une VM, WSL, chez votre voisin ...). Vous allez donc essayer de reconna\u00eetre les diff\u00e9rentes composantes de ces deux syst\u00e8mes d'exploitation. Pour vous aider, voici une liste (non exhaustive) de points \u00e0 regarder : O\u00f9 est le noyau du SE ? est-il prot\u00e9g\u00e9 ? Quel est l'interpr\u00e9teur de commande par d\u00e9faut du SE ? Quelles en sont ses fonctionnalit\u00e9s ? En existe-t-il d'autres (interpreteurs) ? Un SE digne de ce nom doit fournir de nombreux utilitaires de programmation (\u00e9diteurs, compilateurs, interpr\u00e9teurs, d\u00e9bogueurs) : quels sont ceux pr\u00e9sents par d\u00e9faut avec le SE ? \u2026 Warning Si vous observez que le noyaux n'est pas prot\u00e9g\u00e9 sur windows ... Ne le supprimez PAS !! Vous rendrier votre machine inutilisable ... Tip Pour toutes ces recherches, google est votre ami A la place de \"noyau\" on parle souvent historiquement de \"Kernel\" ! Exercice 2 : Ordonnancement simple \u00b6 Soit 5 processus A, B, C, D et E qui sont soumis \u00e0 un CPU dans cet ordre, mais quasi simultan\u00e9ment. Ces travaux ne font pas d'entr\u00e9es-sorties. Leurs dur\u00e9es respectives sont : Processus dur\u00e9e(s) A 10s B 6s C 2s D 4s E 8s Question 1 \u00b6 D\u00e9terminer les temps de r\u00e9ponse de chacun des processus, ainsi que le temps de r\u00e9ponse moyen , pour les disciplines : Pour le moment, on est en algos non pr\u00e9emptifs . FIFO (First In First Out) SJF (Shortest Job First) Priorit\u00e9s, avec le plus petit chiffre \u00e9gal \u00e0 la priorit\u00e9 la plus forte et : Processus dur\u00e9e(s) Priorit\u00e9 A 10s 3 B 6s 5 C 2s 2 D 4s 1 E 8s 4 PS (Proc. Sharing ou Tourniquet/Round Robin) et un quantum de 2s . Question 2 \u00b6 On consid\u00e8re ces 5 processus ordonnanc\u00e9s par la politique \u00e0 priorit\u00e9 pr\u00e9c\u00e9dente. A pr\u00e9sent, les 5 processus ne sont pas soumis en m\u00eame temps . Les dates d\u2019arriv\u00e9e des processus sont respectivement : Processus dur\u00e9e(s) Priorit\u00e9 Soumis \u00e0 (s) A 10s 3 2s B 6s 5 0s C 2s 2 5s D 4s 1 5s E 8s 4 3s Tracez le sch\u00e9ma d\u2019ex\u00e9cution des processus en consid\u00e9rant que : L\u2019ordonnancement est non pr\u00e9emptif comme pr\u00e9c\u00e9demment. Puis qu\u2019il est pr\u00e9emptif . Exercice 3 : Ordonnancement plus complexe \u00b6 On consid\u00e8re un syst\u00e8me monoprocesseur (avec capacit\u00e9 de pr\u00e9emption), de type Linux dans lequel les processus partagent un disque comme seule ressource autre que le processeur . Cette ressource (le HDD ) n\u2019est accessible qu\u2019en acc\u00e8s exclusif et non requ\u00e9rable , c\u2019est-\u00e0-dire qu\u2019une commande disque lanc\u00e9e pour le compte d\u2019un processus se termine normalement avant de pouvoir en lancer une autre. Un processus peut \u00eatre en ex\u00e9cution , en attente d\u2019entr\u00e9es-sorties , en entr\u00e9es-sorties ou en attente du processeur . Les demandes d\u2019entr\u00e9es-sorties sont g\u00e9r\u00e9es \u00e0 l\u2019 anciennet\u00e9 . Dans ce syst\u00e8me, on consid\u00e8re 4 processus soumis \u00e0 t=0 dans l'ordre P1, P2, P3, P4, pour lesquels on sait que: P1 et P2 sont des processus appartenant \u00e0 la classe SCHED_PRIO . Dans cette classe, le processeur est donn\u00e9 au processus de plus haute priorit\u00e9. Ce processus peut \u00eatre pr\u00e9empt\u00e9 par un processus de la m\u00eame classe ayant une priorit\u00e9 sup\u00e9rieure P3 et P4 sont des processus appartenant \u00e0 la classe SCHED_RR . Dans cette classe, le processeur est donn\u00e9 au processus de plus haute priorit\u00e9 pour un quantum de temps \u00e9gal \u00e0 10 ms . La politique appliqu\u00e9e est celle du tourniquet. Les processus de la classe SCHED_PRIO sont toujours plus prioritaires que les processus de la classe SCHED_RR . Les priorit\u00e9s des processus sont \u00e9gales \u00e0 50 pour le processus P1, 49 pour le processus P2, P3 et P4. La plus grande valeur correspond \u00e0 la priorit\u00e9 la plus forte. P1 P2 P3 P4 P1 Calcul pendant 40 ms P2 Calcul pendant 30 ms P3 Calcul pendant 40 ms P4 Calcul pendant 100 ms Lecture disque pendant 50 ms Lecture disque pendant 80 ms Lecture disque pendant 40 ms Calcul pendant 30 ms Calcul pendant 70 ms Calcul pendant 10 ms Lecture disque pendant 40 ms Lecture disque pendant 20 ms Calcul pendant 10 ms Calcul pendant 10 ms \u00c9tablissez le chronogramme d\u2019ex\u00e9cution des 4 processus en figurant les \u00e9tats pr\u00eat (attente du processeur) , ex\u00e9cution , attente I/O (attente du HDD) , I/O (lecture/ecriture HDD) .","title":"TD - Les Bases"},{"location":"05_tdOrdo/#td-ordonnancement","text":"","title":"TD Ordonnancement"},{"location":"05_tdOrdo/#objectifs","text":"Comparaison basique de deux syst\u00e8mes d'exploitation (Windows et Linux). Se rendre compte du travail effectu\u00e9 par le CPU : Ordonnancement manuel de processus.","title":"Objectifs"},{"location":"05_tdOrdo/#prerequis","text":"T\u00e9l\u00e9charger ce fichier BlankTables.xls pour noter vos r\u00e9sultats des exos 2 & 3","title":"Pr\u00e9requis"},{"location":"05_tdOrdo/#exercice-1-comparatif-rapide","text":"Un syst\u00e8me d'exploitation peut \u00eatre vu comme un ensemble de logiciels organis\u00e9s en couches, entre l'utilisateur et la partie mat\u00e9rielle de l'ordinateur. Vous avez a disposition des machine sous Windows et sous Linux ou Mac (la votre, une VM, WSL, chez votre voisin ...). Vous allez donc essayer de reconna\u00eetre les diff\u00e9rentes composantes de ces deux syst\u00e8mes d'exploitation. Pour vous aider, voici une liste (non exhaustive) de points \u00e0 regarder : O\u00f9 est le noyau du SE ? est-il prot\u00e9g\u00e9 ? Quel est l'interpr\u00e9teur de commande par d\u00e9faut du SE ? Quelles en sont ses fonctionnalit\u00e9s ? En existe-t-il d'autres (interpreteurs) ? Un SE digne de ce nom doit fournir de nombreux utilitaires de programmation (\u00e9diteurs, compilateurs, interpr\u00e9teurs, d\u00e9bogueurs) : quels sont ceux pr\u00e9sents par d\u00e9faut avec le SE ? \u2026 Warning Si vous observez que le noyaux n'est pas prot\u00e9g\u00e9 sur windows ... Ne le supprimez PAS !! Vous rendrier votre machine inutilisable ... Tip Pour toutes ces recherches, google est votre ami A la place de \"noyau\" on parle souvent historiquement de \"Kernel\" !","title":"Exercice 1 : Comparatif rapide"},{"location":"05_tdOrdo/#exercice-2-ordonnancement-simple","text":"Soit 5 processus A, B, C, D et E qui sont soumis \u00e0 un CPU dans cet ordre, mais quasi simultan\u00e9ment. Ces travaux ne font pas d'entr\u00e9es-sorties. Leurs dur\u00e9es respectives sont : Processus dur\u00e9e(s) A 10s B 6s C 2s D 4s E 8s","title":"Exercice 2 : Ordonnancement simple"},{"location":"05_tdOrdo/#question-1","text":"D\u00e9terminer les temps de r\u00e9ponse de chacun des processus, ainsi que le temps de r\u00e9ponse moyen , pour les disciplines : Pour le moment, on est en algos non pr\u00e9emptifs . FIFO (First In First Out) SJF (Shortest Job First) Priorit\u00e9s, avec le plus petit chiffre \u00e9gal \u00e0 la priorit\u00e9 la plus forte et : Processus dur\u00e9e(s) Priorit\u00e9 A 10s 3 B 6s 5 C 2s 2 D 4s 1 E 8s 4 PS (Proc. Sharing ou Tourniquet/Round Robin) et un quantum de 2s .","title":"Question 1"},{"location":"05_tdOrdo/#question-2","text":"On consid\u00e8re ces 5 processus ordonnanc\u00e9s par la politique \u00e0 priorit\u00e9 pr\u00e9c\u00e9dente. A pr\u00e9sent, les 5 processus ne sont pas soumis en m\u00eame temps . Les dates d\u2019arriv\u00e9e des processus sont respectivement : Processus dur\u00e9e(s) Priorit\u00e9 Soumis \u00e0 (s) A 10s 3 2s B 6s 5 0s C 2s 2 5s D 4s 1 5s E 8s 4 3s Tracez le sch\u00e9ma d\u2019ex\u00e9cution des processus en consid\u00e9rant que : L\u2019ordonnancement est non pr\u00e9emptif comme pr\u00e9c\u00e9demment. Puis qu\u2019il est pr\u00e9emptif .","title":"Question 2"},{"location":"05_tdOrdo/#exercice-3-ordonnancement-plus-complexe","text":"On consid\u00e8re un syst\u00e8me monoprocesseur (avec capacit\u00e9 de pr\u00e9emption), de type Linux dans lequel les processus partagent un disque comme seule ressource autre que le processeur . Cette ressource (le HDD ) n\u2019est accessible qu\u2019en acc\u00e8s exclusif et non requ\u00e9rable , c\u2019est-\u00e0-dire qu\u2019une commande disque lanc\u00e9e pour le compte d\u2019un processus se termine normalement avant de pouvoir en lancer une autre. Un processus peut \u00eatre en ex\u00e9cution , en attente d\u2019entr\u00e9es-sorties , en entr\u00e9es-sorties ou en attente du processeur . Les demandes d\u2019entr\u00e9es-sorties sont g\u00e9r\u00e9es \u00e0 l\u2019 anciennet\u00e9 . Dans ce syst\u00e8me, on consid\u00e8re 4 processus soumis \u00e0 t=0 dans l'ordre P1, P2, P3, P4, pour lesquels on sait que: P1 et P2 sont des processus appartenant \u00e0 la classe SCHED_PRIO . Dans cette classe, le processeur est donn\u00e9 au processus de plus haute priorit\u00e9. Ce processus peut \u00eatre pr\u00e9empt\u00e9 par un processus de la m\u00eame classe ayant une priorit\u00e9 sup\u00e9rieure P3 et P4 sont des processus appartenant \u00e0 la classe SCHED_RR . Dans cette classe, le processeur est donn\u00e9 au processus de plus haute priorit\u00e9 pour un quantum de temps \u00e9gal \u00e0 10 ms . La politique appliqu\u00e9e est celle du tourniquet. Les processus de la classe SCHED_PRIO sont toujours plus prioritaires que les processus de la classe SCHED_RR . Les priorit\u00e9s des processus sont \u00e9gales \u00e0 50 pour le processus P1, 49 pour le processus P2, P3 et P4. La plus grande valeur correspond \u00e0 la priorit\u00e9 la plus forte. P1 P2 P3 P4 P1 Calcul pendant 40 ms P2 Calcul pendant 30 ms P3 Calcul pendant 40 ms P4 Calcul pendant 100 ms Lecture disque pendant 50 ms Lecture disque pendant 80 ms Lecture disque pendant 40 ms Calcul pendant 30 ms Calcul pendant 70 ms Calcul pendant 10 ms Lecture disque pendant 40 ms Lecture disque pendant 20 ms Calcul pendant 10 ms Calcul pendant 10 ms \u00c9tablissez le chronogramme d\u2019ex\u00e9cution des 4 processus en figurant les \u00e9tats pr\u00eat (attente du processeur) , ex\u00e9cution , attente I/O (attente du HDD) , I/O (lecture/ecriture HDD) .","title":"Exercice 3 : Ordonnancement plus complexe"},{"location":"05_tdOrdoCorr/","text":"TD Ordonnancement Correction \u00b6 Exercice 1 : Comparatif rapide \u00b6 Windows Linux Noyau C:\\Windows\\system32\\ntoskrnl.exe /boot/vmlinuz (lanc\u00e9 par Grub, on le voit dans la conf de Grub) Protection NON, n'importe quel utilisateur peut d\u00e9placer, effacer ou modifier ces fichiers OUI, seul le super utilisateur a le droit d'agir sur ces fichiers. Interpr\u00e9teur de commandes cmd /bin/bash Autres IC. PowerShell zsh, tcsh, sh, ksh, mc, \u2026 Fonctionnalit\u00e9s de l'IC. Traitement des fichiers, de r\u00e9pertoires et d\u00e9marrage d'applications. Tr\u00e8s peu d'applications peuvent \u00eatre lanc\u00e9es en tache de fond Traitement de fichiers, de r\u00e9pertoires et d\u00e9marrage des applications. Le lancement d'application en fond de tache est possible Utilitaires syst\u00e8mes Editeurs de texte, NOTEPAD, WORDPAD, edit sous MSDOS. Utilitaire de dessin (paint),navigateur Internet,lecture d'un CD audio,visionneuse d'images,calculatrice\u2026 Editeurs de texte (vi, ed, pico), utilitaire de dessin, navigateur Internet,lecture d'un CD audio,visionneuse d'images,calculatrice\u2026 Utilitaires de programmation Aucun compilateurs (gcc, java \u2026), \u00e9diteur de liensn outils de d\u00e9veloppement : d\u00e9bogueur (gdb) Exercice 2 : Ordonnancement simple \u00b6 Processus dur\u00e9e(s) Priorit\u00e9 Soumis \u00e0 (s) A 10s 3 2s B 6s 5 0s C 2s 2 5s D 4s 1 5s E 8s 4 3s Question 1 \u00b6 Question 2 \u00b6 Exercice 3 : Ordonnancement plus complexe \u00b6 P1 P2 P3 P4 P1 Calcul pendant 40 ms P2 Calcul pendant 30 ms P3 Calcul pendant 40 ms P4 Calcul pendant 100 ms Lecture disque pendant 50 ms Lecture disque pendant 80 ms Lecture disque pendant 40 ms Calcul pendant 30 ms Calcul pendant 70 ms Calcul pendant 10 ms Lecture disque pendant 40 ms Lecture disque pendant 20 ms Calcul pendant 10 ms Calcul pendant 10 ms","title":""},{"location":"05_tdOrdoCorr/#td-ordonnancement-correction","text":"","title":"TD Ordonnancement Correction"},{"location":"05_tdOrdoCorr/#exercice-1-comparatif-rapide","text":"Windows Linux Noyau C:\\Windows\\system32\\ntoskrnl.exe /boot/vmlinuz (lanc\u00e9 par Grub, on le voit dans la conf de Grub) Protection NON, n'importe quel utilisateur peut d\u00e9placer, effacer ou modifier ces fichiers OUI, seul le super utilisateur a le droit d'agir sur ces fichiers. Interpr\u00e9teur de commandes cmd /bin/bash Autres IC. PowerShell zsh, tcsh, sh, ksh, mc, \u2026 Fonctionnalit\u00e9s de l'IC. Traitement des fichiers, de r\u00e9pertoires et d\u00e9marrage d'applications. Tr\u00e8s peu d'applications peuvent \u00eatre lanc\u00e9es en tache de fond Traitement de fichiers, de r\u00e9pertoires et d\u00e9marrage des applications. Le lancement d'application en fond de tache est possible Utilitaires syst\u00e8mes Editeurs de texte, NOTEPAD, WORDPAD, edit sous MSDOS. Utilitaire de dessin (paint),navigateur Internet,lecture d'un CD audio,visionneuse d'images,calculatrice\u2026 Editeurs de texte (vi, ed, pico), utilitaire de dessin, navigateur Internet,lecture d'un CD audio,visionneuse d'images,calculatrice\u2026 Utilitaires de programmation Aucun compilateurs (gcc, java \u2026), \u00e9diteur de liensn outils de d\u00e9veloppement : d\u00e9bogueur (gdb)","title":"Exercice 1 : Comparatif rapide"},{"location":"05_tdOrdoCorr/#exercice-2-ordonnancement-simple","text":"Processus dur\u00e9e(s) Priorit\u00e9 Soumis \u00e0 (s) A 10s 3 2s B 6s 5 0s C 2s 2 5s D 4s 1 5s E 8s 4 3s","title":"Exercice 2 : Ordonnancement simple"},{"location":"05_tdOrdoCorr/#question-1","text":"","title":"Question 1"},{"location":"05_tdOrdoCorr/#question-2","text":"","title":"Question 2"},{"location":"05_tdOrdoCorr/#exercice-3-ordonnancement-plus-complexe","text":"P1 P2 P3 P4 P1 Calcul pendant 40 ms P2 Calcul pendant 30 ms P3 Calcul pendant 40 ms P4 Calcul pendant 100 ms Lecture disque pendant 50 ms Lecture disque pendant 80 ms Lecture disque pendant 40 ms Calcul pendant 30 ms Calcul pendant 70 ms Calcul pendant 10 ms Lecture disque pendant 40 ms Lecture disque pendant 20 ms Calcul pendant 10 ms Calcul pendant 10 ms","title":"Exercice 3 : Ordonnancement plus complexe"},{"location":"06_kernel/","text":"Noyau (Kernel) \u00b6 C'est le Programme qui assure : La gestion de la m\u00e9moire Le partage du processeur entre les diff\u00e9rentes t\u00e2ches \u00e0 ex\u00e9cuter et les entr\u00e9es/sorties de bas niveau. Une bonne r\u00e9partition des ressources de l\u2019ordinateur (m\u00e9moire,processeur(s), espace disque, imprimante(s), acc\u00e8s r\u00e9seaux) sans intervention des utilisateurs Il est lanc\u00e9 au d\u00e9marrage du syst\u00e8me (le boot) et s\u2019ex\u00e9cute jusqu\u2019\u00e0 son arr\u00eat. C\u2019est un programme relativement petit, qui est charg\u00e9 en m\u00e9moire principale. Il s\u2019ex\u00e9cute en mode superviseur , c\u2019est-\u00e0-dire qu\u2019il a acc\u00e8s \u00e0 toutes les fonctionnalit\u00e9s de la machine : acc\u00e8s \u00e0 toute la m\u00e9moire \u00e0 tous les disques connect\u00e9s manipulations des interruptions, etc... Tous les autres programmes qui s\u2019ex\u00e9cutent sur la machine fonctionnent en mode utilisateur. Ils leur est interdit d\u2019acc\u00e9der directement au mat\u00e9riel et d\u2019utiliser certaines instructions . Chaque programme utilisateur n\u2019a ainsi acc\u00e8s qu\u2019\u00e0 une certaine partie de la m\u00e9moire principale, et il lui est impossible de lire ou \u00e9crire les zones m\u00e9moires attribu\u00e9es aux autres programmes. Lorsque l\u2019un de ces programmes d\u00e9sire acc\u00e9der \u00e0 une ressource g\u00e9r\u00e9e par le noyau, par exemple pour effectuer une op\u00e9ration d\u2019entr\u00e9e/sortie, il ex\u00e9cute un appel syst\u00e8me . Le noyau ex\u00e9cute alors la fonction correspondante, apr\u00e8s avoir v\u00e9rifi\u00e9 que le programme appelant est autoris\u00e9 \u00e0 la r\u00e9aliser .","title":"Noyau"},{"location":"06_kernel/#noyau-kernel","text":"C'est le Programme qui assure : La gestion de la m\u00e9moire Le partage du processeur entre les diff\u00e9rentes t\u00e2ches \u00e0 ex\u00e9cuter et les entr\u00e9es/sorties de bas niveau. Une bonne r\u00e9partition des ressources de l\u2019ordinateur (m\u00e9moire,processeur(s), espace disque, imprimante(s), acc\u00e8s r\u00e9seaux) sans intervention des utilisateurs Il est lanc\u00e9 au d\u00e9marrage du syst\u00e8me (le boot) et s\u2019ex\u00e9cute jusqu\u2019\u00e0 son arr\u00eat. C\u2019est un programme relativement petit, qui est charg\u00e9 en m\u00e9moire principale. Il s\u2019ex\u00e9cute en mode superviseur , c\u2019est-\u00e0-dire qu\u2019il a acc\u00e8s \u00e0 toutes les fonctionnalit\u00e9s de la machine : acc\u00e8s \u00e0 toute la m\u00e9moire \u00e0 tous les disques connect\u00e9s manipulations des interruptions, etc... Tous les autres programmes qui s\u2019ex\u00e9cutent sur la machine fonctionnent en mode utilisateur. Ils leur est interdit d\u2019acc\u00e9der directement au mat\u00e9riel et d\u2019utiliser certaines instructions . Chaque programme utilisateur n\u2019a ainsi acc\u00e8s qu\u2019\u00e0 une certaine partie de la m\u00e9moire principale, et il lui est impossible de lire ou \u00e9crire les zones m\u00e9moires attribu\u00e9es aux autres programmes. Lorsque l\u2019un de ces programmes d\u00e9sire acc\u00e9der \u00e0 une ressource g\u00e9r\u00e9e par le noyau, par exemple pour effectuer une op\u00e9ration d\u2019entr\u00e9e/sortie, il ex\u00e9cute un appel syst\u00e8me . Le noyau ex\u00e9cute alors la fonction correspondante, apr\u00e8s avoir v\u00e9rifi\u00e9 que le programme appelant est autoris\u00e9 \u00e0 la r\u00e9aliser .","title":"Noyau (Kernel)"},{"location":"20_linuxshell/","text":"Pourquoi UNIX ? \u00b6 Bonnes raisons \u00b6 De plus en plus r\u00e9pandu en entreprise Incontournable sur le syst\u00e8mes TR Certaines utilisations n\u00e9cessitent des contraintes de production fortes telles que : la disponibilit\u00e9 (pas de reboot, pas d'arr\u00eat) la performance en charge (nombre d'utilisateurs, de processus) la p\u00e9rennit\u00e9 (car Unix est bas\u00e9 sur des standards) la stabilit\u00e9 / s\u00e9curit\u00e9 (peu de bugs syst\u00e8me) Difficult\u00e9s \u00b6 Une des principales difficult\u00e9s d'Unix est son c\u00f4t\u00e9 ligne de commande un peu d\u00e9mod\u00e9 demandant un minimum d'investissement avant de pouvoir s'en servir efficacement. Ce type d'interface reste pourtant in\u00e9gal\u00e9 depuis 30 ans ! Il existe depuis plus de dix ans des interfaces graphiques comparables au syst\u00e8me Windows. Maintenant, les environnements graphiques sous Linux n'ont rien \u00e0 envier aux syst\u00e8mes de Microsoft. Caract\u00e9ristiques \u00b6 Syst\u00e8me ouvert (pas de code propri\u00e9taire ; seules certaines impl\u00e9mentations sont propri\u00e9taires). Multi-t\u00e2ches (plusieurs programmes peuvent s'ex\u00e9cuter en m\u00eame temps, sans blocage). Multi-utilisateurs (plusieurs utilisateurs travaillent sur la m\u00eame machine en m\u00eame temps), gestion des droits. M\u00e9moire prot\u00e9g\u00e9e (pas d'interaction entre les programmes) et virtuelle (le syst\u00e8me peut utiliser plus de m\u00e9moire que la m\u00e9moire physique disponible). Interface graphique et shell (interpr\u00e9teur de commande). Plusieurs centaines d'outils (manipulation de texte, d\u00e9veloppement de logiciels, communication etc...). R\u00e9sum\u00e9 en vid\u00e9o \u00b6 Le Shell \u00b6 Comme tout syst\u00e8me d'exploitation, UNIX poss\u00e8de un Interpr\u00e9teur de Commandes (I.C.) . C'est un processus utilisateur comme les autres. Il permet : l\u2019ex\u00e9cution des programmes la manipulation des fichiers l'acc\u00e8s aux p\u00e9riph\u00e9riques de l\u2019ordinateur l'automatisation des proc\u00e9dures par fichiers de commandes (scripts en langage Shell) ... Ce \"logiciel d'interface\" fournit \u00e0 l'utilisateur un ensemble de commandes qui lui permettent de \"dialoguer\" avec le syst\u00e8me lui-m\u00eame, le noyau (kernel). Tip UNIX propose en standard plusieurs shell possibles : SH BASH ... Chaque shell peut \u00eatre lanc\u00e9 (activ\u00e9) par sa commande \u00e9quivalente (bsh, ksh, csh). Par d\u00e9faut l'utilisateur lorsqu'il se connecte se retrouve automatiquement dans l'un de ces shell, il a donc un login -shell, configur\u00e9 dans le fichier /etc/passwd Le shell est donc un pseudo langage qui : interpr\u00e8te vos commandes d\u00e9termine les fichiers responsables de la mise en place de votre environnement Warning En BASH, le fichier de configuration du terminal est ~/.bashrc ou ~/.bash_profile Tip Il se nomme ainsi (coquille) car il enveloppe le noyau Unix, toutes les commandes sont pass\u00e9es au noyau \u00e0 travers votre shell. Le Home Directory : ~ \u00b6 Vous \u00eates sous votre HOME quand vous \u00eates sous /home/ your_login C'est un espace disque qui vous appartient, \u00e0 vous et \u00e0 vous seul (voir \"droits\"). Normalement vous pouvez \u00e9crire et lire tous les fichiers qui s'y trouvent. Vous \u00eates responsable de tout ce qui s'y passe (piratage, saturation des espaces disques, etc...). Notion de comptes utilisateur \u00b6 Pour chaque compte vous avez : un login (uid) un mot de passe associ\u00e9 un groupe (gid) un home directory (r\u00e9pertoire de travail) un langage de commandes (shell) Tip Dans un syst\u00e8me UNIX, ces infos sont regroup\u00e9es dans deux fichiers : 1 2 3 cat /etc/passwd cat /etc/group Connexions \u00b6 Locale \u00b6 D\u00e8s que vous \u00eates en local, vous pouvez saisir votre login puis votre password sur l'\u00e9cran (attention unix est \u00ab case sensitive \u00bb). Deux cas peuvent arriver : Soit un \u00e9cran noir avec un simple prompt \">\" Soit un environnement graphique avec une gestion de la souris et des fen\u00eatres suffisamment explicites pour d\u00e9marrer. Warning Pour sortir d'une session, il est imp\u00e9ratif d'utiliser les proc\u00e9dures de d\u00e9connexion. En effet, Unix (comme d'autres syst\u00e8mes) a besoin de sauvegarder certaines donn\u00e9es (flush des buffers lors de la fermeture des fichiers), d\u00e9montage des disques pour forcer une mise \u00e0 jour des fichiers syst\u00e8mes, etc. Aussi si vous faites un \"power off\" d'une machine Unix, vous risquez d'endommager les fichiers sur les disques. Vous devez faire un exit pour revenir \u00e0 la fen\u00eatre primaire, puis \u00e9ventuellement un halt pour arr\u00eater le syst\u00e8me (si vous \u00eates autoris\u00e9 \u00e0 le faire). Distante \u00b6 Pour la connexion \u00e0 distance, vous avez bien s\u00fbr besoin d'\u00eatre d\u00e9j\u00e0 sur un ordinateur Unix/Windows ou autre et d'\u00e9tablir un lien vers la machine Unix cible. Chaque type de connexion d\u00e9pend de la plate-forme d'origine. La plus r\u00e9pandue est SSH , mais on trouve encore du telnet . Tip Les outils le splus connus de SSH sont \"PuTTY\" et \"MobaXterm\".","title":"UNIX"},{"location":"20_linuxshell/#pourquoi-unix","text":"","title":"Pourquoi UNIX ?"},{"location":"20_linuxshell/#bonnes-raisons","text":"De plus en plus r\u00e9pandu en entreprise Incontournable sur le syst\u00e8mes TR Certaines utilisations n\u00e9cessitent des contraintes de production fortes telles que : la disponibilit\u00e9 (pas de reboot, pas d'arr\u00eat) la performance en charge (nombre d'utilisateurs, de processus) la p\u00e9rennit\u00e9 (car Unix est bas\u00e9 sur des standards) la stabilit\u00e9 / s\u00e9curit\u00e9 (peu de bugs syst\u00e8me)","title":"Bonnes raisons"},{"location":"20_linuxshell/#difficultes","text":"Une des principales difficult\u00e9s d'Unix est son c\u00f4t\u00e9 ligne de commande un peu d\u00e9mod\u00e9 demandant un minimum d'investissement avant de pouvoir s'en servir efficacement. Ce type d'interface reste pourtant in\u00e9gal\u00e9 depuis 30 ans ! Il existe depuis plus de dix ans des interfaces graphiques comparables au syst\u00e8me Windows. Maintenant, les environnements graphiques sous Linux n'ont rien \u00e0 envier aux syst\u00e8mes de Microsoft.","title":"Difficult\u00e9s"},{"location":"20_linuxshell/#caracteristiques","text":"Syst\u00e8me ouvert (pas de code propri\u00e9taire ; seules certaines impl\u00e9mentations sont propri\u00e9taires). Multi-t\u00e2ches (plusieurs programmes peuvent s'ex\u00e9cuter en m\u00eame temps, sans blocage). Multi-utilisateurs (plusieurs utilisateurs travaillent sur la m\u00eame machine en m\u00eame temps), gestion des droits. M\u00e9moire prot\u00e9g\u00e9e (pas d'interaction entre les programmes) et virtuelle (le syst\u00e8me peut utiliser plus de m\u00e9moire que la m\u00e9moire physique disponible). Interface graphique et shell (interpr\u00e9teur de commande). Plusieurs centaines d'outils (manipulation de texte, d\u00e9veloppement de logiciels, communication etc...).","title":"Caract\u00e9ristiques"},{"location":"20_linuxshell/#resume-en-video","text":"","title":"R\u00e9sum\u00e9 en vid\u00e9o"},{"location":"20_linuxshell/#le-shell","text":"Comme tout syst\u00e8me d'exploitation, UNIX poss\u00e8de un Interpr\u00e9teur de Commandes (I.C.) . C'est un processus utilisateur comme les autres. Il permet : l\u2019ex\u00e9cution des programmes la manipulation des fichiers l'acc\u00e8s aux p\u00e9riph\u00e9riques de l\u2019ordinateur l'automatisation des proc\u00e9dures par fichiers de commandes (scripts en langage Shell) ... Ce \"logiciel d'interface\" fournit \u00e0 l'utilisateur un ensemble de commandes qui lui permettent de \"dialoguer\" avec le syst\u00e8me lui-m\u00eame, le noyau (kernel). Tip UNIX propose en standard plusieurs shell possibles : SH BASH ... Chaque shell peut \u00eatre lanc\u00e9 (activ\u00e9) par sa commande \u00e9quivalente (bsh, ksh, csh). Par d\u00e9faut l'utilisateur lorsqu'il se connecte se retrouve automatiquement dans l'un de ces shell, il a donc un login -shell, configur\u00e9 dans le fichier /etc/passwd Le shell est donc un pseudo langage qui : interpr\u00e8te vos commandes d\u00e9termine les fichiers responsables de la mise en place de votre environnement Warning En BASH, le fichier de configuration du terminal est ~/.bashrc ou ~/.bash_profile Tip Il se nomme ainsi (coquille) car il enveloppe le noyau Unix, toutes les commandes sont pass\u00e9es au noyau \u00e0 travers votre shell.","title":"Le Shell"},{"location":"20_linuxshell/#le-home-directory","text":"Vous \u00eates sous votre HOME quand vous \u00eates sous /home/ your_login C'est un espace disque qui vous appartient, \u00e0 vous et \u00e0 vous seul (voir \"droits\"). Normalement vous pouvez \u00e9crire et lire tous les fichiers qui s'y trouvent. Vous \u00eates responsable de tout ce qui s'y passe (piratage, saturation des espaces disques, etc...).","title":"Le Home Directory : ~"},{"location":"20_linuxshell/#notion-de-comptes-utilisateur","text":"Pour chaque compte vous avez : un login (uid) un mot de passe associ\u00e9 un groupe (gid) un home directory (r\u00e9pertoire de travail) un langage de commandes (shell) Tip Dans un syst\u00e8me UNIX, ces infos sont regroup\u00e9es dans deux fichiers : 1 2 3 cat /etc/passwd cat /etc/group","title":"Notion de comptes utilisateur"},{"location":"20_linuxshell/#connexions","text":"","title":"Connexions"},{"location":"20_linuxshell/#locale","text":"D\u00e8s que vous \u00eates en local, vous pouvez saisir votre login puis votre password sur l'\u00e9cran (attention unix est \u00ab case sensitive \u00bb). Deux cas peuvent arriver : Soit un \u00e9cran noir avec un simple prompt \">\" Soit un environnement graphique avec une gestion de la souris et des fen\u00eatres suffisamment explicites pour d\u00e9marrer. Warning Pour sortir d'une session, il est imp\u00e9ratif d'utiliser les proc\u00e9dures de d\u00e9connexion. En effet, Unix (comme d'autres syst\u00e8mes) a besoin de sauvegarder certaines donn\u00e9es (flush des buffers lors de la fermeture des fichiers), d\u00e9montage des disques pour forcer une mise \u00e0 jour des fichiers syst\u00e8mes, etc. Aussi si vous faites un \"power off\" d'une machine Unix, vous risquez d'endommager les fichiers sur les disques. Vous devez faire un exit pour revenir \u00e0 la fen\u00eatre primaire, puis \u00e9ventuellement un halt pour arr\u00eater le syst\u00e8me (si vous \u00eates autoris\u00e9 \u00e0 le faire).","title":"Locale"},{"location":"20_linuxshell/#distante","text":"Pour la connexion \u00e0 distance, vous avez bien s\u00fbr besoin d'\u00eatre d\u00e9j\u00e0 sur un ordinateur Unix/Windows ou autre et d'\u00e9tablir un lien vers la machine Unix cible. Chaque type de connexion d\u00e9pend de la plate-forme d'origine. La plus r\u00e9pandue est SSH , mais on trouve encore du telnet . Tip Les outils le splus connus de SSH sont \"PuTTY\" et \"MobaXterm\".","title":"Distante"},{"location":"21_cmdshell/","text":"Th\u00e9orie des commandes \u00b6 Structure \u00b6 Un commande est en fait un programme compil\u00e9 , souvent en C, accessible partout dans l'OS. Comme tout programme classique, il peut recevoir des param\u00e8tres de l'ext\u00e9rieur. Dans l'IC, on a cette structure 1 nom_de_la_commande param1 param2 param3 ... Tip La commande est chacun de ses param\u00e8tres sont s\u00e9par\u00e9es par des ESPACES Gestion des Flux \u00b6 Th\u00e9orie \u00b6 Exemples \u00b6 1 2 3 4 5 6 7 8 9 10 11 cat < toto ls > dir.txt ls >> dir.txt rm * 2 > erreur.log rm * 2 >> erreur.log ps \u2013ef | grep toto O\u00f9 trouver l'information ? \u00b6 Quand on a acc\u00e8s \u00e0 internet, la meilleure source et la plus rapide : Google ! Sinon, n'hesitez pas \u00e0 utiliser la commande man nom_de_la_commande qui d\u00e9crit pr\u00e9cisement toutes les possibilit\u00e9s d'une commande. Tip Les pages manquantes d'un manuel peuvent \u00eatre ajout\u00e9es... On peut aussi traduire le man en fran\u00e7ais","title":"Commandes Shell"},{"location":"21_cmdshell/#theorie-des-commandes","text":"","title":"Th\u00e9orie des commandes"},{"location":"21_cmdshell/#structure","text":"Un commande est en fait un programme compil\u00e9 , souvent en C, accessible partout dans l'OS. Comme tout programme classique, il peut recevoir des param\u00e8tres de l'ext\u00e9rieur. Dans l'IC, on a cette structure 1 nom_de_la_commande param1 param2 param3 ... Tip La commande est chacun de ses param\u00e8tres sont s\u00e9par\u00e9es par des ESPACES","title":"Structure"},{"location":"21_cmdshell/#gestion-des-flux","text":"","title":"Gestion des Flux"},{"location":"21_cmdshell/#theorie","text":"","title":"Th\u00e9orie"},{"location":"21_cmdshell/#exemples","text":"1 2 3 4 5 6 7 8 9 10 11 cat < toto ls > dir.txt ls >> dir.txt rm * 2 > erreur.log rm * 2 >> erreur.log ps \u2013ef | grep toto","title":"Exemples"},{"location":"21_cmdshell/#ou-trouver-linformation","text":"Quand on a acc\u00e8s \u00e0 internet, la meilleure source et la plus rapide : Google ! Sinon, n'hesitez pas \u00e0 utiliser la commande man nom_de_la_commande qui d\u00e9crit pr\u00e9cisement toutes les possibilit\u00e9s d'une commande. Tip Les pages manquantes d'un manuel peuvent \u00eatre ajout\u00e9es... On peut aussi traduire le man en fran\u00e7ais","title":"O\u00f9 trouver l'information ?"},{"location":"22_tpShell/","text":"TP Commandes Linux \u00b6 Objectifs \u00b6 Le second objectif du cours est de maitriser les bases du Shell Unix , via un TP. Exercice 1 : Variables d\u2019environnements \u00b6 Afficher l\u2019ensemble de vos variables d\u2019environnement. Solution 1 env Afficher le contenu de la variable PATH. Solution 1 echo $PATH Donner la signification de PATH, PS1, HOME, et TERM Solution PATH : Liste des chemins (absolus) des dossiers contenant des binaires (executables). PS1 : Aspect du Prompt principal. HOME : Chemin du Home Directory de l'utilisateur courant. TERM : Type de terminal en cours d'usage pour l'utilisateur courant. Exercice 2 : Initiation aux commandes de base d'Unix \u00b6 Tip Ne pas oublier que le descriptif des commandes est disponible en utilisant le manuel (commande man). Pour savoir o\u00f9 se trouve un fichier ou commande = whereis, which, apropos Utilisation des commandes : alias et unalias \u00b6 Quels sont les alias pr\u00e9sents sur votre machine ? Solution 1 alias Cr\u00e9er un alias lu qui r\u00e9alise la commande ls -lrt Solution 1 alias lu = 'ls -lrt' Utiliser cet alias Solution 1 lu Supprimer cet alias Solution 1 unalias lu Utilisation des commandes : mkdir, rm, cd, cp, mv, touch, chmod, pwd \u00b6 Cr\u00e9er, dans votre environnement de travail ( /home/ username ), l\u2019arborescence de dossiers suivante : (Bonus : en une seule commande !) 1 2 3 4 5 6 7 8 9 10 11 . ` -- SE | -- TP1 | | -- delivery | | -- dpc | ` -- script ` -- TP2 | -- bin | -- inc | -- obj ` -- src Solution 1 mkdir -p SE/ { TP1/ { dpc,script,delivery } ,TP2/ { bin,obj,src,inc }} Installer la commande tree qui permet d'afficher l'arborescence ci-dessus Solution 1 2 sudo apt-get install tree tree Afficher son r\u00e9pertoire courant Solution 1 pwd Cr\u00e9er le fichier bonjour.c sous SE/TP2/src contenant les lignes suivantes : (En utilisant un editeur en ligne de commande ou graphique, au choix) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // directive du pr\u00e9processeur #include <stdio.h> /* prototype des fonctions */ /* programme principal */ int main () { printf ( \"Bonjour \\n \" ) ; /* 0100123456123 0100123457123 0100123458123 0100123459123 0100123450123 0100123451123 0100123451123 */ } D\u00e9placer vous sous votre home directory et cr\u00e9er le fichier vide config.txt Solution 1 2 cd touch config.txt D\u00e9placer vous par un d\u00e9placement absolu sous le r\u00e9pertoire src et compiler le programme bonjour.c en un programme ex\u00e9cutable bonjour . Le r\u00e9sultat de la compilation est d\u00e9plac\u00e9 sous bin . Solution 1 2 cd /home/my_user/SE/TP2/src gcc bonjour.c -o ../bin/bonjour Afficher les types des fichiers bonjour et bonjour.c Solution 1 2 file bonjour.c file ../bin/bonjour D\u00e9placez vous par un d\u00e9placement relatif sous TP2/bin Solution 1 cd ../bin Modifier les droits du fichier bonjour afin qu\u2019il soit : en lecture, \u00e9criture, ex\u00e9cution pour le owner en lecture, ex\u00e9cution pour le groupe et non accessible pour les autres. Solution 1 chmod 750 bonjour D\u00e9placez vous sous votre home directory et modifiez de fa\u00e7on r\u00e9cursive l\u2019ensemble des droits (directories + fichiers) de TP2 selon les conditions de la question pr\u00e9c\u00e9dente. Solution 1 2 cd chmod -R 750 SE/TP2/ Tip Vous pouvez v\u00e9rifier avec la commande tree -p Copier le fichier bonjour.c en salut.c en local. Tip Pour faire une copie locale il faut etre dans le repertoire concern\u00e9, et copier au m\u00eame endroit. Solution 1 2 cd SE/TP2/src/ cp bonjour.c salut.c Copier le r\u00e9pertoire TP2 en TP3 avec l\u2019ensemble de ses fichiers Solution 1 2 cd ../../ cp -R TP2 TP3 D\u00e9placer le fichier salut.c de TP3 dans SE/TP2/src en l\u2019appelant salut1.c Solution 1 mv TP3/src/salut.c TP2/src/salut1.c Effacer le fichier bonjour.c de TP3 Solution 1 rm TP3/src/bonjour.c Effacer TP3 Solution 1 rm -R TP3/ Utilisation des commandes : chmod, chown, chgrp, ls, ln \u00b6 Changer le owner du fichier TP2/src/salut.c par n'importe quel autre utilisateur pr\u00e9sent sur votre machine, monitorer le r\u00e9sultat Tip Pour connaitre les users disponible, allez voir le contenu du fichier /etc/passwd avec la command cat Filtrer les users qui possedent un home directory dans /home cat /etc/passwd | grep home Solution 1 2 chown new_owner TP2/src/salut.c ls -la Changer le groupe de ce fichier par un groupe connu sur la machine Tip Pour connaitre les groupes disponible, allez voir le contenu du fichier /etc/group avec la command cat cat /etc/group Solution 1 2 chgrp new_group TP2/src/salut.c ls -la Changer en une seule commande le owner et goupe de TP2 et des fichiers qu\u2019il contient pour vous les redonner Tip Utilisez la commande id pour connaitre votre user:groupe Solution 1 chown -R mon_user:mon_groupe TP2/ Se positionner sur son home directory et cr\u00e9er un lien symbolique vers le fichier salut.c de TP2 Solution 1 2 3 cd ln -s SE/TP2/src/salut.c monLien ls -la Editer ce lien. Expliquer la diff\u00e9rence entre un lien permanent et un lien symbolique. Solution 1 cat monLien Note Un lien symbolique pointe vers le nom d'un fichier existant. Un lieu permanent (ou physique) pointe vers l'esapace m\u00e9moire o\u00f9 se siture le fichier. Monitoring disques \u00b6 Quel est l\u2019espace disponible sur votre disque ? Solution 1 df -h Quelles sont les partitions disques pr\u00e9sentent sur votre syst\u00e8me ? Solution 1 sudo fdisk -l Utilisation de la commande export : \u00b6 Modifier le contenu de la variable d\u2019environnement PATH afin d\u2019y ajouter le chemin absolu vers le r\u00e9pertoire TP2/bin . Warning Attention \u00e0 ne pas \u00e9craser totalement la variable PATH ! Solution 1 export PATH = $PATH :/home/user/SE/TP2/bin V\u00e9rifier que depuis n'importe quel folder, vous pouvez lancer bonjour de la fa\u00e7on suivante : bonjour \u21b5 V\u00e9rifiez que bonjour execute bien votre binaire avec which bonjour Modifier votre profil utilisateur afin de modifier PATH comme pr\u00e9c\u00e9demment, de mani\u00e8re permanente. Solution Il suffit de copier coller l'export export PATH=$PATH:/home/user/SE/TP2/bin dans le fichier ~/.bashrc Script : \u00b6 D\u00e9placez vous sous SE/TP1/script et cr\u00e9er, en 1 seule commande, un fichier essai.bash contenant #!/bin/bash Solution 1 2 cd ~/SE/TP1/script echo '#!/bin/bash' > essai.bash Ajouter \u00e0 la fin de essai.bash la ligne \u00ab ls \u2013lrt \u00bb (en une seule commande) Solution 1 echo 'ls -lrt' >> essai.bash Ex\u00e9cutez essai.bash Warning Pensez \u00e0 vous donner les droits d'execution avant ... chmod u+x essai.bash Solution 1 ./essai.bash Utilisation de grep, ps, netstat,wc : \u00b6 Rechercher l\u2019occurrence \u00ab include \u00bb dans le fichier bonjour.c Solution 1 2 cd ~/SE/TP2/src grep \"include\" bonjour.c Afficher l\u2019ensemble des processus en cours Solution 1 ps -edf Afficher l\u2019ensemble des sockets en \u00e9tat \u2018ESTABLISHED\u2019 sur votre machine et comptez les. Solution 1 netstat \u2013a | grep ESTABLISHED | wc -l Utilisation de la commande find : \u00b6 Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Solution 1 find ~/SE -name \"*.c\" Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des occurrences de \u00ab printf \u00bb dans l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Solution 1 find ~/SE -name \"*.c\" -exec grep \"printf\" {} \\; -print Utilisation de la commande xargs: \u00b6 Cr\u00e9er une sauvegarde de l\u2019ensemble des fichiers c se trouvant sous SE/TP2/src en le copiant en nom_du_fichier.c_backup Tip bonjour.c est copi\u00e9 en bonjour.c_backup Solution 1 ls *.c | xargs -t -i cp {} {} _backup Machine/user/syst\u00e8me/terminal \u00b6 Afficher qui est logg\u00e9 sur votre machine ? Afficher quel est le nom de votre machine ? Afficher quel est le nom de votre syst\u00e8me ? Afficher quel votre num\u00e9ro utilisateur et groupe ? Solution 1 2 3 4 who hostname uname -a id -u Les Process : utilisation des commandes ps, top, jobs, CTRL^Z, fg, bg, kill \u00b6 Monitorer de mani\u00e8re dynamique l\u2019ensemble des process en cours Solution 1 top Dans un autre terminal, lancer un process long en background, par example firefox , ou ajouter une boucle infinie au programme bonjour et utiliser `bonjour . bonjour.c 1 2 3 4 5 6 7 8 9 10 11 12 // directive du pr\u00e9processeur #include <stdio.h> /* prototype des fonctions */ /* programme principal */ int main () { while ( 1 ){ printf ( \"Bonjour \\n \" ) ; sleep ( 2 ); } } Solution 1 bonjour & Monitorer le de fa\u00e7on statique Solution 1 2 3 ps | grep bonjour 9034 ttys000 0 :00.00 bonjour Tuer le violemment Solution 1 kill -9 9034 Lancer un process, l\u2019interrompre et le mettre en ex\u00e9cution en background Solution 1 2 3 bonjour ctrl + z bg Monitorer le Solution 1 ps | grep bonjour Basculer ce process en foreground Solution 1 fg Stopper le par un signal d\u2019interruption Solution 1 ctrl + c","title":"TP Linux Commands"},{"location":"22_tpShell/#tp-commandes-linux","text":"","title":"TP Commandes Linux"},{"location":"22_tpShell/#objectifs","text":"Le second objectif du cours est de maitriser les bases du Shell Unix , via un TP.","title":"Objectifs"},{"location":"22_tpShell/#exercice-1-variables-denvironnements","text":"Afficher l\u2019ensemble de vos variables d\u2019environnement. Solution 1 env Afficher le contenu de la variable PATH. Solution 1 echo $PATH Donner la signification de PATH, PS1, HOME, et TERM Solution PATH : Liste des chemins (absolus) des dossiers contenant des binaires (executables). PS1 : Aspect du Prompt principal. HOME : Chemin du Home Directory de l'utilisateur courant. TERM : Type de terminal en cours d'usage pour l'utilisateur courant.","title":"Exercice 1 : Variables d\u2019environnements"},{"location":"22_tpShell/#exercice-2-initiation-aux-commandes-de-base-dunix","text":"Tip Ne pas oublier que le descriptif des commandes est disponible en utilisant le manuel (commande man). Pour savoir o\u00f9 se trouve un fichier ou commande = whereis, which, apropos","title":"Exercice 2 : Initiation aux commandes de base d'Unix"},{"location":"22_tpShell/#utilisation-des-commandes-alias-et-unalias","text":"Quels sont les alias pr\u00e9sents sur votre machine ? Solution 1 alias Cr\u00e9er un alias lu qui r\u00e9alise la commande ls -lrt Solution 1 alias lu = 'ls -lrt' Utiliser cet alias Solution 1 lu Supprimer cet alias Solution 1 unalias lu","title":"Utilisation des commandes : alias et unalias"},{"location":"22_tpShell/#utilisation-des-commandes-mkdir-rm-cd-cp-mv-touch-chmod-pwd","text":"Cr\u00e9er, dans votre environnement de travail ( /home/ username ), l\u2019arborescence de dossiers suivante : (Bonus : en une seule commande !) 1 2 3 4 5 6 7 8 9 10 11 . ` -- SE | -- TP1 | | -- delivery | | -- dpc | ` -- script ` -- TP2 | -- bin | -- inc | -- obj ` -- src Solution 1 mkdir -p SE/ { TP1/ { dpc,script,delivery } ,TP2/ { bin,obj,src,inc }} Installer la commande tree qui permet d'afficher l'arborescence ci-dessus Solution 1 2 sudo apt-get install tree tree Afficher son r\u00e9pertoire courant Solution 1 pwd Cr\u00e9er le fichier bonjour.c sous SE/TP2/src contenant les lignes suivantes : (En utilisant un editeur en ligne de commande ou graphique, au choix) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // directive du pr\u00e9processeur #include <stdio.h> /* prototype des fonctions */ /* programme principal */ int main () { printf ( \"Bonjour \\n \" ) ; /* 0100123456123 0100123457123 0100123458123 0100123459123 0100123450123 0100123451123 0100123451123 */ } D\u00e9placer vous sous votre home directory et cr\u00e9er le fichier vide config.txt Solution 1 2 cd touch config.txt D\u00e9placer vous par un d\u00e9placement absolu sous le r\u00e9pertoire src et compiler le programme bonjour.c en un programme ex\u00e9cutable bonjour . Le r\u00e9sultat de la compilation est d\u00e9plac\u00e9 sous bin . Solution 1 2 cd /home/my_user/SE/TP2/src gcc bonjour.c -o ../bin/bonjour Afficher les types des fichiers bonjour et bonjour.c Solution 1 2 file bonjour.c file ../bin/bonjour D\u00e9placez vous par un d\u00e9placement relatif sous TP2/bin Solution 1 cd ../bin Modifier les droits du fichier bonjour afin qu\u2019il soit : en lecture, \u00e9criture, ex\u00e9cution pour le owner en lecture, ex\u00e9cution pour le groupe et non accessible pour les autres. Solution 1 chmod 750 bonjour D\u00e9placez vous sous votre home directory et modifiez de fa\u00e7on r\u00e9cursive l\u2019ensemble des droits (directories + fichiers) de TP2 selon les conditions de la question pr\u00e9c\u00e9dente. Solution 1 2 cd chmod -R 750 SE/TP2/ Tip Vous pouvez v\u00e9rifier avec la commande tree -p Copier le fichier bonjour.c en salut.c en local. Tip Pour faire une copie locale il faut etre dans le repertoire concern\u00e9, et copier au m\u00eame endroit. Solution 1 2 cd SE/TP2/src/ cp bonjour.c salut.c Copier le r\u00e9pertoire TP2 en TP3 avec l\u2019ensemble de ses fichiers Solution 1 2 cd ../../ cp -R TP2 TP3 D\u00e9placer le fichier salut.c de TP3 dans SE/TP2/src en l\u2019appelant salut1.c Solution 1 mv TP3/src/salut.c TP2/src/salut1.c Effacer le fichier bonjour.c de TP3 Solution 1 rm TP3/src/bonjour.c Effacer TP3 Solution 1 rm -R TP3/","title":"Utilisation des commandes : mkdir, rm, cd, cp, mv, touch, chmod, pwd"},{"location":"22_tpShell/#utilisation-des-commandes-chmod-chown-chgrp-ls-ln","text":"Changer le owner du fichier TP2/src/salut.c par n'importe quel autre utilisateur pr\u00e9sent sur votre machine, monitorer le r\u00e9sultat Tip Pour connaitre les users disponible, allez voir le contenu du fichier /etc/passwd avec la command cat Filtrer les users qui possedent un home directory dans /home cat /etc/passwd | grep home Solution 1 2 chown new_owner TP2/src/salut.c ls -la Changer le groupe de ce fichier par un groupe connu sur la machine Tip Pour connaitre les groupes disponible, allez voir le contenu du fichier /etc/group avec la command cat cat /etc/group Solution 1 2 chgrp new_group TP2/src/salut.c ls -la Changer en une seule commande le owner et goupe de TP2 et des fichiers qu\u2019il contient pour vous les redonner Tip Utilisez la commande id pour connaitre votre user:groupe Solution 1 chown -R mon_user:mon_groupe TP2/ Se positionner sur son home directory et cr\u00e9er un lien symbolique vers le fichier salut.c de TP2 Solution 1 2 3 cd ln -s SE/TP2/src/salut.c monLien ls -la Editer ce lien. Expliquer la diff\u00e9rence entre un lien permanent et un lien symbolique. Solution 1 cat monLien Note Un lien symbolique pointe vers le nom d'un fichier existant. Un lieu permanent (ou physique) pointe vers l'esapace m\u00e9moire o\u00f9 se siture le fichier.","title":"Utilisation des commandes : chmod, chown, chgrp, ls, ln"},{"location":"22_tpShell/#monitoring-disques","text":"Quel est l\u2019espace disponible sur votre disque ? Solution 1 df -h Quelles sont les partitions disques pr\u00e9sentent sur votre syst\u00e8me ? Solution 1 sudo fdisk -l","title":"Monitoring disques"},{"location":"22_tpShell/#utilisation-de-la-commande-export","text":"Modifier le contenu de la variable d\u2019environnement PATH afin d\u2019y ajouter le chemin absolu vers le r\u00e9pertoire TP2/bin . Warning Attention \u00e0 ne pas \u00e9craser totalement la variable PATH ! Solution 1 export PATH = $PATH :/home/user/SE/TP2/bin V\u00e9rifier que depuis n'importe quel folder, vous pouvez lancer bonjour de la fa\u00e7on suivante : bonjour \u21b5 V\u00e9rifiez que bonjour execute bien votre binaire avec which bonjour Modifier votre profil utilisateur afin de modifier PATH comme pr\u00e9c\u00e9demment, de mani\u00e8re permanente. Solution Il suffit de copier coller l'export export PATH=$PATH:/home/user/SE/TP2/bin dans le fichier ~/.bashrc","title":"Utilisation de la commande export :"},{"location":"22_tpShell/#script","text":"D\u00e9placez vous sous SE/TP1/script et cr\u00e9er, en 1 seule commande, un fichier essai.bash contenant #!/bin/bash Solution 1 2 cd ~/SE/TP1/script echo '#!/bin/bash' > essai.bash Ajouter \u00e0 la fin de essai.bash la ligne \u00ab ls \u2013lrt \u00bb (en une seule commande) Solution 1 echo 'ls -lrt' >> essai.bash Ex\u00e9cutez essai.bash Warning Pensez \u00e0 vous donner les droits d'execution avant ... chmod u+x essai.bash Solution 1 ./essai.bash","title":"Script :"},{"location":"22_tpShell/#utilisation-de-grep-ps-netstatwc","text":"Rechercher l\u2019occurrence \u00ab include \u00bb dans le fichier bonjour.c Solution 1 2 cd ~/SE/TP2/src grep \"include\" bonjour.c Afficher l\u2019ensemble des processus en cours Solution 1 ps -edf Afficher l\u2019ensemble des sockets en \u00e9tat \u2018ESTABLISHED\u2019 sur votre machine et comptez les. Solution 1 netstat \u2013a | grep ESTABLISHED | wc -l","title":"Utilisation de grep, ps, netstat,wc :"},{"location":"22_tpShell/#utilisation-de-la-commande-find","text":"Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Solution 1 find ~/SE -name \"*.c\" Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des occurrences de \u00ab printf \u00bb dans l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Solution 1 find ~/SE -name \"*.c\" -exec grep \"printf\" {} \\; -print","title":"Utilisation de la commande find :"},{"location":"22_tpShell/#utilisation-de-la-commande-xargs","text":"Cr\u00e9er une sauvegarde de l\u2019ensemble des fichiers c se trouvant sous SE/TP2/src en le copiant en nom_du_fichier.c_backup Tip bonjour.c est copi\u00e9 en bonjour.c_backup Solution 1 ls *.c | xargs -t -i cp {} {} _backup","title":"Utilisation de la commande xargs:"},{"location":"22_tpShell/#machineusersystemeterminal","text":"Afficher qui est logg\u00e9 sur votre machine ? Afficher quel est le nom de votre machine ? Afficher quel est le nom de votre syst\u00e8me ? Afficher quel votre num\u00e9ro utilisateur et groupe ? Solution 1 2 3 4 who hostname uname -a id -u","title":"Machine/user/syst\u00e8me/terminal"},{"location":"22_tpShell/#les-process-utilisation-des-commandes-ps-top-jobs-ctrlz-fg-bg-kill","text":"Monitorer de mani\u00e8re dynamique l\u2019ensemble des process en cours Solution 1 top Dans un autre terminal, lancer un process long en background, par example firefox , ou ajouter une boucle infinie au programme bonjour et utiliser `bonjour . bonjour.c 1 2 3 4 5 6 7 8 9 10 11 12 // directive du pr\u00e9processeur #include <stdio.h> /* prototype des fonctions */ /* programme principal */ int main () { while ( 1 ){ printf ( \"Bonjour \\n \" ) ; sleep ( 2 ); } } Solution 1 bonjour & Monitorer le de fa\u00e7on statique Solution 1 2 3 ps | grep bonjour 9034 ttys000 0 :00.00 bonjour Tuer le violemment Solution 1 kill -9 9034 Lancer un process, l\u2019interrompre et le mettre en ex\u00e9cution en background Solution 1 2 3 bonjour ctrl + z bg Monitorer le Solution 1 ps | grep bonjour Basculer ce process en foreground Solution 1 fg Stopper le par un signal d\u2019interruption Solution 1 ctrl + c","title":"Les Process : utilisation des commandes ps, top, jobs, CTRL^Z, fg, bg, kill"},{"location":"30_tpRegexp/","text":"TP Regexp \u00b6 Dans ce TP, vous apprendrez \u00e0 utiliser les outils d'expression r\u00e9guli\u00e8res. Travail sur les fichiers : sed, awk, diff, cut, sort \u00b6 Sur le fichier C utilis\u00e9 au TP pr\u00e9c\u00e9dent : Transformer les commentaires // en /* */ \u2013 Affichage stdout Transformer les commentaires /* */ en // \u2013 Affichage dans un fichier bonjour.cpp Comparer les fichiers bonjour.cpp et bonjour.c Sous SE/TP1/script, cr\u00e9er le fichier titi.txt contenant les lignes suivantes : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Alain DERUE Clothilde DERUE Adresse 7 av du President Carter 13000 Marseille cedex 01 TP_OA :MSISDN :KI :IMSI :TP_UD TP_SCTS :TP_DA :TAC :IMEI: :TP_UD 0100123456123 0100123457123 0100123458123 0100123459123 0100123460123 0100123461123 0100123462123 0100123463123 Remplacer le nom de famille DERUE par Christophe \u2013 Affichage stdout Remplacer les lignes pr\u00e9fix\u00e9es par 0100 et suffix\u00e9e par 123, par le contenu situ\u00e9 entre ces deux occurrences \u2013 Affichage stdout. Exemple : 0100123456123 devient 123456 Ne garder que les chiffres du fichier \u2013 Affichage stdout Afficher, sur stdout, les champs 1 et 4 issue du d\u00e9coupage \u00e0 partir du token : du fichier titi.txt Trier les lignes de titi.txt Effacer les lignes vides contenues dans le fichier bonjour.c Ecrivez un script awk qui permet d'afficher chaque groupe disponible sur votre machine, suivit de son num\u00e9ro GID, si et seulement si son GID est > 1. Formattez la sortie comme ceci : Nom du groupe : [groupName] / ID du groupe : [GID] Voici un example de fichier /etc/group si vous n'en avez pas : 1 2 3 4 5 6 wheel:*:0:root daemon:*:1:root kmem:*:5:root jberger:*:200:user user1:*:201:user eleve:*:500:eleves Archiver son travail : tar, gzip \u00b6 Se positionner sous votre home directory et archiver SE en donnant votre nom \u00e0 l'archive.","title":"TP Regexp"},{"location":"30_tpRegexp/#tp-regexp","text":"Dans ce TP, vous apprendrez \u00e0 utiliser les outils d'expression r\u00e9guli\u00e8res.","title":"TP Regexp"},{"location":"30_tpRegexp/#travail-sur-les-fichiers-sed-awk-diff-cut-sort","text":"Sur le fichier C utilis\u00e9 au TP pr\u00e9c\u00e9dent : Transformer les commentaires // en /* */ \u2013 Affichage stdout Transformer les commentaires /* */ en // \u2013 Affichage dans un fichier bonjour.cpp Comparer les fichiers bonjour.cpp et bonjour.c Sous SE/TP1/script, cr\u00e9er le fichier titi.txt contenant les lignes suivantes : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Alain DERUE Clothilde DERUE Adresse 7 av du President Carter 13000 Marseille cedex 01 TP_OA :MSISDN :KI :IMSI :TP_UD TP_SCTS :TP_DA :TAC :IMEI: :TP_UD 0100123456123 0100123457123 0100123458123 0100123459123 0100123460123 0100123461123 0100123462123 0100123463123 Remplacer le nom de famille DERUE par Christophe \u2013 Affichage stdout Remplacer les lignes pr\u00e9fix\u00e9es par 0100 et suffix\u00e9e par 123, par le contenu situ\u00e9 entre ces deux occurrences \u2013 Affichage stdout. Exemple : 0100123456123 devient 123456 Ne garder que les chiffres du fichier \u2013 Affichage stdout Afficher, sur stdout, les champs 1 et 4 issue du d\u00e9coupage \u00e0 partir du token : du fichier titi.txt Trier les lignes de titi.txt Effacer les lignes vides contenues dans le fichier bonjour.c Ecrivez un script awk qui permet d'afficher chaque groupe disponible sur votre machine, suivit de son num\u00e9ro GID, si et seulement si son GID est > 1. Formattez la sortie comme ceci : Nom du groupe : [groupName] / ID du groupe : [GID] Voici un example de fichier /etc/group si vous n'en avez pas : 1 2 3 4 5 6 wheel:*:0:root daemon:*:1:root kmem:*:5:root jberger:*:200:user user1:*:201:user eleve:*:500:eleves","title":"Travail sur les fichiers : sed, awk, diff, cut, sort"},{"location":"30_tpRegexp/#archiver-son-travail-tar-gzip","text":"Se positionner sous votre home directory et archiver SE en donnant votre nom \u00e0 l'archive.","title":"Archiver son travail : tar, gzip"},{"location":"30_tpRegexpCorrection/","text":"TP Regexp \u00b6 Dans ce TP, vous apprendrez \u00e0 utiliser les outils d'expression r\u00e9guli\u00e8res. Travail sur les fichiers : sed, awk, diff, cut, sort \u00b6 Sur le fichier C utilis\u00e9 au TP pr\u00e9c\u00e9dent : Transformer les commentaires // en /* */ \u2013 Affichage stdout 1 sed -e 's://\\(.*\\):/*\\1*/:g' bonjour.c Transformer les commentaires /* */ en // \u2013 Affichage dans un fichier bonjour.cpp 1 sed -e 's:/\\*\\(.*\\)\\*/:// \\1:g' bonjour.c > bonjour.cpp Comparer les fichiers bonjour.cpp et bonjour.c 1 diff bonjour.c bonjour.cpp Sous SE/TP1/script, cr\u00e9er le fichier titi.txt contenant les lignes suivantes : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Alain DERUE Clothilde DERUE Adresse 7 av du President Carter 13000 Marseille cedex 01 TP_OA :MSISDN :KI :IMSI :TP_UD TP_SCTS :TP_DA :TAC :IMEI: :TP_UD 0100123456123 0100123457123 0100123458123 0100123459123 0100123460123 0100123461123 0100123462123 0100123463123 Remplacer le nom de famille DERUE par Christophe \u2013 Affichage stdout 1 sed 's/DERUE/Christophe/g' titi.txt Remplacer les lignes pr\u00e9fix\u00e9es par 0100 et suffix\u00e9e par 123, par le contenu situ\u00e9 entre ces deux occurrences \u2013 Affichage stdout. Exemple : 0100123456123 devient 123456 1 sed -e 's:0100\\(.*\\)123:\\1:g' titi.txt Ne garder que les chiffres du fichier \u2013 Affichage stdout 1 2 sed -e 's/[a-zA-Z:_-]//g' titi.txt sed -n -e '^ *[0-9][0-9]*$/p' titi.txt Afficher, sur stdout, les champs 1 et 4 issue du d\u00e9coupage \u00e0 partir du token : du fichier titi.txt 1 cut -d : -f 1 ,4 titi.txt Trier les lignes de titi.txt 1 sort titi.txt Effacer les lignes vides contenues dans le fichier bonjour.c 1 sed -e '/^$/d' bonjour.c Ecrivez un script awk qui permet d'afficher chaque groupe disponible sur votre machine, suivit de son num\u00e9ro GID, si et seulement si son GID est > 1. Formattez la sortie comme ceci : Nom du groupe : [groupName] / ID du groupe : [GID] Voici un example de fichier /etc/group si vous n'en avez pas : 1 2 3 4 5 6 wheel:*:0:root daemon:*:1:root kmem:*:5:root jberger:*:200:user user1:*:201:user eleve:*:500:eleves 1 awk -F \":\" '$3 > 1 { print \"Nom du groupe : \" $1 \" / ID du groupe : \" $3 }' /etc/group Archiver son travail : tar, gzip \u00b6 Se positionner sous votre home directory et archiver SE en donnant votre nom \u00e0 l'archive. 1 tar -cvzf nom.tar.gz SE/","title":""},{"location":"30_tpRegexpCorrection/#tp-regexp","text":"Dans ce TP, vous apprendrez \u00e0 utiliser les outils d'expression r\u00e9guli\u00e8res.","title":"TP Regexp"},{"location":"30_tpRegexpCorrection/#travail-sur-les-fichiers-sed-awk-diff-cut-sort","text":"Sur le fichier C utilis\u00e9 au TP pr\u00e9c\u00e9dent : Transformer les commentaires // en /* */ \u2013 Affichage stdout 1 sed -e 's://\\(.*\\):/*\\1*/:g' bonjour.c Transformer les commentaires /* */ en // \u2013 Affichage dans un fichier bonjour.cpp 1 sed -e 's:/\\*\\(.*\\)\\*/:// \\1:g' bonjour.c > bonjour.cpp Comparer les fichiers bonjour.cpp et bonjour.c 1 diff bonjour.c bonjour.cpp Sous SE/TP1/script, cr\u00e9er le fichier titi.txt contenant les lignes suivantes : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Alain DERUE Clothilde DERUE Adresse 7 av du President Carter 13000 Marseille cedex 01 TP_OA :MSISDN :KI :IMSI :TP_UD TP_SCTS :TP_DA :TAC :IMEI: :TP_UD 0100123456123 0100123457123 0100123458123 0100123459123 0100123460123 0100123461123 0100123462123 0100123463123 Remplacer le nom de famille DERUE par Christophe \u2013 Affichage stdout 1 sed 's/DERUE/Christophe/g' titi.txt Remplacer les lignes pr\u00e9fix\u00e9es par 0100 et suffix\u00e9e par 123, par le contenu situ\u00e9 entre ces deux occurrences \u2013 Affichage stdout. Exemple : 0100123456123 devient 123456 1 sed -e 's:0100\\(.*\\)123:\\1:g' titi.txt Ne garder que les chiffres du fichier \u2013 Affichage stdout 1 2 sed -e 's/[a-zA-Z:_-]//g' titi.txt sed -n -e '^ *[0-9][0-9]*$/p' titi.txt Afficher, sur stdout, les champs 1 et 4 issue du d\u00e9coupage \u00e0 partir du token : du fichier titi.txt 1 cut -d : -f 1 ,4 titi.txt Trier les lignes de titi.txt 1 sort titi.txt Effacer les lignes vides contenues dans le fichier bonjour.c 1 sed -e '/^$/d' bonjour.c Ecrivez un script awk qui permet d'afficher chaque groupe disponible sur votre machine, suivit de son num\u00e9ro GID, si et seulement si son GID est > 1. Formattez la sortie comme ceci : Nom du groupe : [groupName] / ID du groupe : [GID] Voici un example de fichier /etc/group si vous n'en avez pas : 1 2 3 4 5 6 wheel:*:0:root daemon:*:1:root kmem:*:5:root jberger:*:200:user user1:*:201:user eleve:*:500:eleves 1 awk -F \":\" '$3 > 1 { print \"Nom du groupe : \" $1 \" / ID du groupe : \" $3 }' /etc/group","title":"Travail sur les fichiers : sed, awk, diff, cut, sort"},{"location":"30_tpRegexpCorrection/#archiver-son-travail-tar-gzip","text":"Se positionner sous votre home directory et archiver SE en donnant votre nom \u00e0 l'archive. 1 tar -cvzf nom.tar.gz SE/","title":"Archiver son travail : tar, gzip"},{"location":"40_progsys_execv/","text":"Programmation Syst\u00e8me - Execv \u00b6 Recouvrement \u00b6 On va maintenant chercher \u00e0 coder nos deux processus dans deux programmes diff\u00e9rents, afin d'all\u00e9ger la lecture du code ! Primitive de Recouvrement \u00b6 Execv \u00b6 1 int execv ( char * ref , char * argv []); ref : chemin absolu du programme \u00e0 executer argv: tableau de pointeur vers des caract\u00e8res (tableau de chaines de caract\u00e8res) \u2013 argv[0]: nom du nouveau programme \u00e0 ex\u00e9cuter \u2013 argv[1]: le 1er param\u00e8tre \u2013 argv[2]: le 2\u00e8me param\u00e8tre \u2013 \u2026\u2026\u2026\u2026. \u2013 argv[N]: le Ni\u00e8me param\u00e8tre \u2013 argv[N+1]: NULL Permet de lancer l\u2019ex\u00e9cution, par le processus appelant, d\u2019un nouveau programme en son sein : les instructions du nouveau programme recouvrent celles de l \u2019ancien programme retourne -1 en cas d\u2019\u00e9chec Important ! Remarque : pas de cr\u00e9ation de nouveau processus Rien n'est fait au hasard ... Si on regarde bien, on a d\u00e9j\u00e0 manipul\u00e9 un tableau similaire dans la fonction main du programme calculatrice ... Dans ce dernier, les arguments venaient de notre input en CLI, et c'est l'OS qui se chargeait de remplir le tableau pour nous. Ici, nous rempla\u00e7ons l'OS pour instancier manuellement un processus dans un existant. C'est donc \u00e0 nous de remplir ce tableau cette fois ci !! Exemple \u00b6 Code \u00b6 Programme principal : Programme fils : /* calcul.c */ int main ( void ) { int pid , status ; char * argv [ 2 ]; pid = fork (); if ( pid == 0 ) { printf ( \"je le fils:pid=%d \" , getpid ()); argv [ 0 ] = \"carre\" ; argv [ 1 ] = NULL ; execv ( \" /home/carre \" , argv ); } printf ( \" je suis le p\u00e8re: pid=%d \" , getpid ()); wait ( & status ); printf ( \" le carre = %d \" , status / 256 ); exit ( 0 ); } /* carre.c*/ int main ( int argc , char * arg []) { int x ; printf ( \" je le fils:pid=%d \" , getpid ()); printf ( \"pid de mon pere=%d \" , getppid ()); printf ( \" x = \" ); scanf ( \" %d \" , & x ); x = x * x : exit ( x ); } Sch\u00e9ma \u00b6","title":"Programmation Syst\u00e8me - Execv"},{"location":"40_progsys_execv/#programmation-systeme-execv","text":"","title":"Programmation Syst\u00e8me - Execv"},{"location":"40_progsys_execv/#recouvrement","text":"On va maintenant chercher \u00e0 coder nos deux processus dans deux programmes diff\u00e9rents, afin d'all\u00e9ger la lecture du code !","title":"Recouvrement"},{"location":"40_progsys_execv/#primitive-de-recouvrement","text":"","title":"Primitive de Recouvrement"},{"location":"40_progsys_execv/#execv","text":"1 int execv ( char * ref , char * argv []); ref : chemin absolu du programme \u00e0 executer argv: tableau de pointeur vers des caract\u00e8res (tableau de chaines de caract\u00e8res) \u2013 argv[0]: nom du nouveau programme \u00e0 ex\u00e9cuter \u2013 argv[1]: le 1er param\u00e8tre \u2013 argv[2]: le 2\u00e8me param\u00e8tre \u2013 \u2026\u2026\u2026\u2026. \u2013 argv[N]: le Ni\u00e8me param\u00e8tre \u2013 argv[N+1]: NULL Permet de lancer l\u2019ex\u00e9cution, par le processus appelant, d\u2019un nouveau programme en son sein : les instructions du nouveau programme recouvrent celles de l \u2019ancien programme retourne -1 en cas d\u2019\u00e9chec Important ! Remarque : pas de cr\u00e9ation de nouveau processus Rien n'est fait au hasard ... Si on regarde bien, on a d\u00e9j\u00e0 manipul\u00e9 un tableau similaire dans la fonction main du programme calculatrice ... Dans ce dernier, les arguments venaient de notre input en CLI, et c'est l'OS qui se chargeait de remplir le tableau pour nous. Ici, nous rempla\u00e7ons l'OS pour instancier manuellement un processus dans un existant. C'est donc \u00e0 nous de remplir ce tableau cette fois ci !!","title":"Execv"},{"location":"40_progsys_execv/#exemple","text":"","title":"Exemple"},{"location":"40_progsys_execv/#code","text":"Programme principal : Programme fils : /* calcul.c */ int main ( void ) { int pid , status ; char * argv [ 2 ]; pid = fork (); if ( pid == 0 ) { printf ( \"je le fils:pid=%d \" , getpid ()); argv [ 0 ] = \"carre\" ; argv [ 1 ] = NULL ; execv ( \" /home/carre \" , argv ); } printf ( \" je suis le p\u00e8re: pid=%d \" , getpid ()); wait ( & status ); printf ( \" le carre = %d \" , status / 256 ); exit ( 0 ); } /* carre.c*/ int main ( int argc , char * arg []) { int x ; printf ( \" je le fils:pid=%d \" , getpid ()); printf ( \"pid de mon pere=%d \" , getppid ()); printf ( \" x = \" ); scanf ( \" %d \" , & x ); x = x * x : exit ( x ); }","title":"Code"},{"location":"40_progsys_execv/#schema","text":"","title":"Sch\u00e9ma"},{"location":"40_progsys_files/","text":"Programmation Syst\u00e8me - E/S bas niveau \u00b6","title":"Programmation Syst\u00e8me - Signaux"},{"location":"40_progsys_files/#programmation-systeme-es-bas-niveau","text":"","title":"Programmation Syst\u00e8me - E/S bas niveau"},{"location":"40_progsys_fork/","text":"Programmation Syst\u00e8me - Fork \u00b6 Rappels : Programme vs. Processus \u00b6 important Programme : entit\u00e9 statique , une suite d'instructions compil\u00e9es Processus : entit\u00e9 dynamique , poss\u00e8de un PID, c'est l'\u00e9xecution d'un programme. Poss\u00e8de un contexte propre. Cr\u00e9ation d'un Processus \u00b6 R\u00e8gle d'Or : tout processus UNIX peut cr\u00e9er un ou plusieurs processus. Donc pour cr\u00e9er un processus nouveau, il en faut d\u00e9j\u00e0 un exustant ... qui va \u00eatre clon\u00e9 , puis sp\u00e9cialis\u00e9 . Il y a donc une filiation entre les processus ! Primitives \u00b6 PID Courant \u00b6 1 pid_t getpid ( void ); Retourne le pid du processus courant (appelant) PID du P\u00e8re \u00b6 1 pid_t getppid ( void ); Retourne le pid du p\u00e8re du processus courant (appelant) Tip Le pendant en Shell serait la commande : ps Suspension \u00b6 1 2 int sleep ( int nb_sec ); int usleep ( int nb_msec ); sleep endort le processus jusqu'\u00e0 ce que nb_sec secondes se soient \u00e9coul\u00e9es, ou jusqu'\u00e0 ce qu'un signal non-ignor\u00e9 soit re\u00e7u. usleep endort le processus jusqu'\u00e0 ce que nb_msec micro-secondes se soient \u00e9coul\u00e9es, ou jusqu'\u00e0 ce qu'un signal non-ignor\u00e9 soit re\u00e7u. Renvoient z\u00e9ro si le temps pr\u00e9vu s'est \u00e9coul\u00e9, ou le nombre de secondes (micro-secondes) restantes si un signal a r\u00e9veill\u00e9 le processus. Cr\u00e9ation de processus \u00b6 1 pid_t fork ( void ); Permet la cr\u00e9ation dynamique d\u2019un nouveau processus (fils) . par duplication du processus courant (p\u00e8re) . Le processus fils ne diff\u00e8re du processus p\u00e8re que par les pid et ppid . Les 2 processus ( p\u00e8re et fils ) s\u2019ex\u00e9cutent de mani\u00e8re concurrente ! Tip Biblioth\u00e8ques : #inlude <sys/types.h> #inlude <unistd.h> Retourne un entier : En cas de succ\u00e8s: 0 dans le fils pid du fils dans le p\u00e8re En cas d\u2019\u00e9chec -1 dans le p\u00e8re le fils n\u2019est pas cr\u00e9\u00e9 Tr\u00e8s Important ! La valeur retourn\u00e9e par fork permet donc de faire la distinction entre le p\u00e8re et le fils ! Exemple basique \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) printf ( \" Je suis le FILS \" ); else printf ( \" Je suis le PERE \" ); return 0 ; } Apr\u00e8s fork : allocation d\u2019une ent\u00e9e dans la table des processus au nouveau processus allocation d \u2019un pid au nouveau processus duplication du contexte du processus p\u00e8re (donn\u00e9es, pile\u2026) retour du pid du processus fils \u00e0 son p\u00e8re et 0 au processus fils Affichons les PID respectifs : Dans le ==p\u00e8re== (PID suppos\u00e9 : 1234) : Dans le ==fils== (PID suppos\u00e9 : 2345): int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); printf ( \" mon pid est = %d \" , getpid ()); } else { printf ( \" Je suis le pere \" ); printf ( \" mon pid est = %d \" , getpid ()); } } int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); printf ( \" mon pid est = %d \" , getpid ()); } else { printf ( \" Je suis le pere \" ); printf ( \" mon pid est = %d \" , getpid ()); } } Affichages : 1 2 Je suis le pere mon pid est = 1234 Je suis le fils mon pid est = 2345 PID diff\u00e9rents: 1234 et 2345 Les 2 processus ex\u00e9cute le m\u00eame programme ! On ne peut pas pr\u00e9dire l'ordre des printf !! Synchronisation \u00b6 Primitives \u00b6 Exit \u00b6 1 void exit ( int status ); Exit : \u2013 termine le processus appelant. \u2013 transmet la valeur de status (le mot d\u2019\u00e9tat ) au processus p\u00e8re \u2013 ferme les descripteurs de fichiers ouverts \u2013 un signal SIGCHLD est envoy\u00e9 au processus p\u00e8re. Wait \u00b6 1 pid_t wait ( int * status ); Wait : \u2013 attend la terminaison ou l'arr\u00eat d'un processus fils (fils quelconque ). \u2013 retourne le PID d'un processus termin\u00e9, -1 en cas d\u2019erreur (si tous sont d\u00e9j\u00e0 termin\u00e9s). \u2013 stocke la valeur transmise par le fils (exit) dans l'entier point\u00e9 par status. Warning Le status est cod\u00e9 sur le 2\u00e8me octet de l'int point\u00e9 : Exemple complet \u00b6 Dans le ==p\u00e8re== (PID suppos\u00e9 : 1234) : Dans le ==fils== (PID suppos\u00e9 : 2345): int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); exit ( 3 ); } else { printf ( \" Je suis le pere \" ); printf ( \" j \u2019attends la fin de mon fils); wait ( & status ); printf ( \" status = %d \" , status >> 8 ); } return 0 ; } int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); exit ( 3 ); } else { printf ( \" Je suis le pere \" ); printf ( \" j \u2019attends la fin de mon fils); wait ( & status ); printf ( \" status = %d \" , status >> 8 ); } return 0 ; } Affichages : 1 2 3 4 Je suis le fils Je suis le pere j \u2019attends la fin de mon fils status = 3 On ne peut pas pr\u00e9dire l'ordre des 3 premiers printf . Par contre on sait forc\u00e9ment que l'affichage du status se fera en dernier ! Lorsqu\u2019un processus se termine ( exit ), le syst\u00e8me d\u00e9truit son contexte, sauf son entr\u00e9e de la table des processus Le procesus est alors dit dans un \u00e9tat ZOMBI (momentan\u00e9 si bien cod\u00e9) Le processus p\u00e8re r\u00e9cup\u00e8re la mort de son fils ( wait ), et d\u00e9truit son entr\u00e9e de la table des processus. Le fils dispara\u00eet compl\u00e8tement du syst\u00e8me (n\u2019est plus zombi). La communication entre le fils zombi et le p\u00e8re s \u2019effectue par le biais d \u2019un signal transmis du fils vers le p\u00e8re (signal SIGCHLD : la mort du fils). Un processus fils d\u00e9funt reste zombie jusqu\u2019\u00e0 ce que son p\u00e8re ait pris connaissance de sa mort (wait). Danger Une mauvaise synchronisation = saturation table des processus = blocage total du syst\u00e8me ! Adoption \u00b6 Si le p\u00e8re d\u00e9c\u00e8de avant le fils alors le fils deviendra orphelin et sera adopt\u00e9 par le processus de PID 1 (init). Exemple de Zombi \u00b6 Warning Ceci est un code faux ... \u00e0 des fins p\u00e9dagogiques ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*Programme pgmzombi.c */ int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" je suis le FILS pid = %d \\n \" , getpid ()); sleep ( 10 ); printf ( \" je suis le FILS, \u00e0 dieu \\n \" ); } else { printf ( \"je suis le PERE pid = %d \\n \" , getpid ()); printf ( \"je suis le PERE je boucle \u00e0 l\u2019infini \" ); for ( ; ; ); } return 0 ; } On suppose que le pid du p\u00e8re est 1234 et celui du fils est 2345. R\u00e9sultat de l\u2019ex\u00e9cution en arri\u00e8re-plan: > pgmzombi & je suis le pere pid = 1234 je suis le pere je boucle \u00e0 l\u2019infini je suis le fils pid = 2345 je suis le fils, \u00e0 dieu Avant la mort du fils : Apr\u00e8s la mort du fils : # ps 1234 tty3 0 :04 pgmzombi 2345 tty3 0 :03 pgmzombi # ps 1234 tty3 0 :04 pgmzombi 2345 tty3 0 :03 [ defunct ] Exercice - Zombi War \u00b6 Copiez/Collez ce programme Zombi. Observez vous m\u00eame le Zombi. Enfin, corrigez le code afin de le rendre propre !","title":"Programmation Syst\u00e8me - Fork"},{"location":"40_progsys_fork/#programmation-systeme-fork","text":"","title":"Programmation Syst\u00e8me - Fork"},{"location":"40_progsys_fork/#rappels-programme-vs-processus","text":"important Programme : entit\u00e9 statique , une suite d'instructions compil\u00e9es Processus : entit\u00e9 dynamique , poss\u00e8de un PID, c'est l'\u00e9xecution d'un programme. Poss\u00e8de un contexte propre.","title":"Rappels : Programme vs. Processus"},{"location":"40_progsys_fork/#creation-dun-processus","text":"R\u00e8gle d'Or : tout processus UNIX peut cr\u00e9er un ou plusieurs processus. Donc pour cr\u00e9er un processus nouveau, il en faut d\u00e9j\u00e0 un exustant ... qui va \u00eatre clon\u00e9 , puis sp\u00e9cialis\u00e9 . Il y a donc une filiation entre les processus !","title":"Cr\u00e9ation d'un Processus"},{"location":"40_progsys_fork/#primitives","text":"","title":"Primitives"},{"location":"40_progsys_fork/#pid-courant","text":"1 pid_t getpid ( void ); Retourne le pid du processus courant (appelant)","title":"PID Courant"},{"location":"40_progsys_fork/#pid-du-pere","text":"1 pid_t getppid ( void ); Retourne le pid du p\u00e8re du processus courant (appelant) Tip Le pendant en Shell serait la commande : ps","title":"PID du P\u00e8re"},{"location":"40_progsys_fork/#suspension","text":"1 2 int sleep ( int nb_sec ); int usleep ( int nb_msec ); sleep endort le processus jusqu'\u00e0 ce que nb_sec secondes se soient \u00e9coul\u00e9es, ou jusqu'\u00e0 ce qu'un signal non-ignor\u00e9 soit re\u00e7u. usleep endort le processus jusqu'\u00e0 ce que nb_msec micro-secondes se soient \u00e9coul\u00e9es, ou jusqu'\u00e0 ce qu'un signal non-ignor\u00e9 soit re\u00e7u. Renvoient z\u00e9ro si le temps pr\u00e9vu s'est \u00e9coul\u00e9, ou le nombre de secondes (micro-secondes) restantes si un signal a r\u00e9veill\u00e9 le processus.","title":"Suspension"},{"location":"40_progsys_fork/#creation-de-processus","text":"1 pid_t fork ( void ); Permet la cr\u00e9ation dynamique d\u2019un nouveau processus (fils) . par duplication du processus courant (p\u00e8re) . Le processus fils ne diff\u00e8re du processus p\u00e8re que par les pid et ppid . Les 2 processus ( p\u00e8re et fils ) s\u2019ex\u00e9cutent de mani\u00e8re concurrente ! Tip Biblioth\u00e8ques : #inlude <sys/types.h> #inlude <unistd.h> Retourne un entier : En cas de succ\u00e8s: 0 dans le fils pid du fils dans le p\u00e8re En cas d\u2019\u00e9chec -1 dans le p\u00e8re le fils n\u2019est pas cr\u00e9\u00e9 Tr\u00e8s Important ! La valeur retourn\u00e9e par fork permet donc de faire la distinction entre le p\u00e8re et le fils !","title":"Cr\u00e9ation de processus"},{"location":"40_progsys_fork/#exemple-basique","text":"1 2 3 4 5 6 7 8 9 10 11 12 int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) printf ( \" Je suis le FILS \" ); else printf ( \" Je suis le PERE \" ); return 0 ; } Apr\u00e8s fork : allocation d\u2019une ent\u00e9e dans la table des processus au nouveau processus allocation d \u2019un pid au nouveau processus duplication du contexte du processus p\u00e8re (donn\u00e9es, pile\u2026) retour du pid du processus fils \u00e0 son p\u00e8re et 0 au processus fils Affichons les PID respectifs : Dans le ==p\u00e8re== (PID suppos\u00e9 : 1234) : Dans le ==fils== (PID suppos\u00e9 : 2345): int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); printf ( \" mon pid est = %d \" , getpid ()); } else { printf ( \" Je suis le pere \" ); printf ( \" mon pid est = %d \" , getpid ()); } } int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); printf ( \" mon pid est = %d \" , getpid ()); } else { printf ( \" Je suis le pere \" ); printf ( \" mon pid est = %d \" , getpid ()); } } Affichages : 1 2 Je suis le pere mon pid est = 1234 Je suis le fils mon pid est = 2345 PID diff\u00e9rents: 1234 et 2345 Les 2 processus ex\u00e9cute le m\u00eame programme ! On ne peut pas pr\u00e9dire l'ordre des printf !!","title":"Exemple basique"},{"location":"40_progsys_fork/#synchronisation","text":"","title":"Synchronisation"},{"location":"40_progsys_fork/#primitives_1","text":"","title":"Primitives"},{"location":"40_progsys_fork/#exit","text":"1 void exit ( int status ); Exit : \u2013 termine le processus appelant. \u2013 transmet la valeur de status (le mot d\u2019\u00e9tat ) au processus p\u00e8re \u2013 ferme les descripteurs de fichiers ouverts \u2013 un signal SIGCHLD est envoy\u00e9 au processus p\u00e8re.","title":"Exit"},{"location":"40_progsys_fork/#wait","text":"1 pid_t wait ( int * status ); Wait : \u2013 attend la terminaison ou l'arr\u00eat d'un processus fils (fils quelconque ). \u2013 retourne le PID d'un processus termin\u00e9, -1 en cas d\u2019erreur (si tous sont d\u00e9j\u00e0 termin\u00e9s). \u2013 stocke la valeur transmise par le fils (exit) dans l'entier point\u00e9 par status. Warning Le status est cod\u00e9 sur le 2\u00e8me octet de l'int point\u00e9 :","title":"Wait"},{"location":"40_progsys_fork/#exemple-complet","text":"Dans le ==p\u00e8re== (PID suppos\u00e9 : 1234) : Dans le ==fils== (PID suppos\u00e9 : 2345): int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); exit ( 3 ); } else { printf ( \" Je suis le pere \" ); printf ( \" j \u2019attends la fin de mon fils); wait ( & status ); printf ( \" status = %d \" , status >> 8 ); } return 0 ; } int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); exit ( 3 ); } else { printf ( \" Je suis le pere \" ); printf ( \" j \u2019attends la fin de mon fils); wait ( & status ); printf ( \" status = %d \" , status >> 8 ); } return 0 ; } Affichages : 1 2 3 4 Je suis le fils Je suis le pere j \u2019attends la fin de mon fils status = 3 On ne peut pas pr\u00e9dire l'ordre des 3 premiers printf . Par contre on sait forc\u00e9ment que l'affichage du status se fera en dernier ! Lorsqu\u2019un processus se termine ( exit ), le syst\u00e8me d\u00e9truit son contexte, sauf son entr\u00e9e de la table des processus Le procesus est alors dit dans un \u00e9tat ZOMBI (momentan\u00e9 si bien cod\u00e9) Le processus p\u00e8re r\u00e9cup\u00e8re la mort de son fils ( wait ), et d\u00e9truit son entr\u00e9e de la table des processus. Le fils dispara\u00eet compl\u00e8tement du syst\u00e8me (n\u2019est plus zombi). La communication entre le fils zombi et le p\u00e8re s \u2019effectue par le biais d \u2019un signal transmis du fils vers le p\u00e8re (signal SIGCHLD : la mort du fils). Un processus fils d\u00e9funt reste zombie jusqu\u2019\u00e0 ce que son p\u00e8re ait pris connaissance de sa mort (wait). Danger Une mauvaise synchronisation = saturation table des processus = blocage total du syst\u00e8me !","title":"Exemple complet"},{"location":"40_progsys_fork/#adoption","text":"Si le p\u00e8re d\u00e9c\u00e8de avant le fils alors le fils deviendra orphelin et sera adopt\u00e9 par le processus de PID 1 (init).","title":"Adoption"},{"location":"40_progsys_fork/#exemple-de-zombi","text":"Warning Ceci est un code faux ... \u00e0 des fins p\u00e9dagogiques ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*Programme pgmzombi.c */ int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" je suis le FILS pid = %d \\n \" , getpid ()); sleep ( 10 ); printf ( \" je suis le FILS, \u00e0 dieu \\n \" ); } else { printf ( \"je suis le PERE pid = %d \\n \" , getpid ()); printf ( \"je suis le PERE je boucle \u00e0 l\u2019infini \" ); for ( ; ; ); } return 0 ; } On suppose que le pid du p\u00e8re est 1234 et celui du fils est 2345. R\u00e9sultat de l\u2019ex\u00e9cution en arri\u00e8re-plan: > pgmzombi & je suis le pere pid = 1234 je suis le pere je boucle \u00e0 l\u2019infini je suis le fils pid = 2345 je suis le fils, \u00e0 dieu Avant la mort du fils : Apr\u00e8s la mort du fils : # ps 1234 tty3 0 :04 pgmzombi 2345 tty3 0 :03 pgmzombi # ps 1234 tty3 0 :04 pgmzombi 2345 tty3 0 :03 [ defunct ]","title":"Exemple de Zombi"},{"location":"40_progsys_fork/#exercice-zombi-war","text":"Copiez/Collez ce programme Zombi. Observez vous m\u00eame le Zombi. Enfin, corrigez le code afin de le rendre propre !","title":"Exercice - Zombi War"},{"location":"40_progsys_signals/","text":"Programmation Syst\u00e8me - Signaux \u00b6","title":"Programmation Syst\u00e8me - Signaux"},{"location":"40_progsys_signals/#programmation-systeme-signaux","text":"","title":"Programmation Syst\u00e8me - Signaux"},{"location":"41_progsys_tp1_proc/","text":"Programmation Syst\u00e8me : TP1 - Echauffement \u00b6 Programme avec Param\u00e8tres \u00b6 Exercice 1 \u00b6 Ecrire un programme qui affiche ses param\u00e8tres puis les variables d\u2019environnement de votre OS. Tip En C, il existe 3 prototypes de fonction main : 1 2 3 int main ( void ); int main ( int argc , char * argv []); int main ( int argc , char * argv [], char * arge []); A vous de choisir celle appropri\u00e9e ! Un petit coup de Google ne fait pas de mal ... Exercice 2 \u00b6 Ecrire un programme de calculatrice simple, qui prends deux nombres ainsi que l'op\u00e9rateur en param\u00e8tres. Ex d'\u00e9xecution attendue : 1 2 calc 5 + 3 r\u00e9sultat = 8","title":"Programmation Syst\u00e8me - TP1 Echauffement"},{"location":"41_progsys_tp1_proc/#programmation-systeme-tp1-echauffement","text":"","title":"Programmation Syst\u00e8me : TP1 - Echauffement"},{"location":"41_progsys_tp1_proc/#programme-avec-parametres","text":"","title":"Programme avec Param\u00e8tres"},{"location":"41_progsys_tp1_proc/#exercice-1","text":"Ecrire un programme qui affiche ses param\u00e8tres puis les variables d\u2019environnement de votre OS. Tip En C, il existe 3 prototypes de fonction main : 1 2 3 int main ( void ); int main ( int argc , char * argv []); int main ( int argc , char * argv [], char * arge []); A vous de choisir celle appropri\u00e9e ! Un petit coup de Google ne fait pas de mal ...","title":"Exercice 1"},{"location":"41_progsys_tp1_proc/#exercice-2","text":"Ecrire un programme de calculatrice simple, qui prends deux nombres ainsi que l'op\u00e9rateur en param\u00e8tres. Ex d'\u00e9xecution attendue : 1 2 calc 5 + 3 r\u00e9sultat = 8","title":"Exercice 2"},{"location":"41_progsys_tp1_proc_corr/","text":"Programmation Syst\u00e8me : TP1 - Processus \u00b6 Programme avec Param\u00e8tres \u00b6 Exercice 1 \u00b6 Ecrire un programme qui affiche ses param\u00e8tres puis les variables d\u2019environnement de votre OS. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdlib.h> int main ( int argc , char * argv [], char * arge []) { //Partie variables d'env printf ( \"Nombre d'arguments = %d \\n \" , argc ); for ( i = 0 ; i < argc ; i ++ ) printf ( \"Argument %d : %s \\n \" , i , argv [ i ]); printf ( \"Variables d'env: \\n \" ); i = 0 ; while ( arge [ i ] != NULL ) { printf ( \"Variable d'Env[%d]=%s \\n \" , i , arge [ i ]); i ++ ; } return 0 ; } Exercice 2 \u00b6 Ecrire un programme de calculatrice simple, qui prends deux nombres ainsi que l'op\u00e9rateur en param\u00e8tres. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdlib.h> int main ( int argc , char * argv [], char * arge []) { //Partie Calculette int o1 , o2 ; char op ; int res ; int i = 0 ; if ( argc != 4 ) { printf ( \" \\t J'attends 3 arguments pass\u00e9s au programme ! \\n \" ); exit ( 0 ); } o1 = atoi ( argv [ 1 ]); o2 = atoi ( argv [ 3 ]); op =* ( argv [ 2 ]); switch ( op ) { case '+' : res = o1 + o2 ; break ; case '-' : res = o1 - o2 ; break ; case '*' : res = o1 * o2 ; break ; case '/' : res = o1 / o2 ; break ; default : printf ( \"erreur d'operande \\n \" ); } printf ( \"res=%d \\n \" , res ); return 0 ; } Zombie War \u00b6 Exercice 3 \u00b6 Ecrire un programme en C qui cr\u00e9er deux processus et qui met en valeur le ph\u00e9nom\u00e8ne des processus zombie . Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { pid_t pid ; pid = fork (); if ( pid == -1 ) { printf ( \"Error on fork \\n \" ); exit ( -1 ); } if ( pid == 0 ) { printf ( \"FILS : mon pid = %d et celui de mon pere est %d \\n \" , getpid (), getppid ()); sleep ( 10 ); printf ( \">>> mort du fils \\n \" ); } else { printf ( \" PERE : mon pid = %d, j'attends la mort de mon fils \\n \" , getpid ()); sleep ( 20 ); //Pendant 10 sec on observe le zombie ... exit ( 0 ); } } Le corriger pour le rendre \u00ab propre \u00bb ! Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { pid_t pid ; pid = fork (); if ( pid == -1 ) { printf ( \"Error on fork \\n \" ); exit ( -1 ); } if ( pid == 0 ) { printf ( \"FILS : mon pid = %d et celui de mon pere est %d \\n \" , getpid (), getppid ()); sleep ( 10 ); printf ( \">>> mort du fils \\n \" ); exit ( 0 ); } else { printf ( \" PERE : mon pid = %d, j'attends la mort de mon fils \\n \" , getpid ()); wait ( NULL ); printf ( \"Pere : j'ai recut la mort de mon fils, je peux mourir en Paix. RIP. \\n \" ); sleep ( 10 ); // Pendant ces 10 sec, on n'observe PLUS de Zombie :) exit ( 0 ); } }","title":""},{"location":"41_progsys_tp1_proc_corr/#programmation-systeme-tp1-processus","text":"","title":"Programmation Syst\u00e8me : TP1 - Processus"},{"location":"41_progsys_tp1_proc_corr/#programme-avec-parametres","text":"","title":"Programme avec Param\u00e8tres"},{"location":"41_progsys_tp1_proc_corr/#exercice-1","text":"Ecrire un programme qui affiche ses param\u00e8tres puis les variables d\u2019environnement de votre OS. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdlib.h> int main ( int argc , char * argv [], char * arge []) { //Partie variables d'env printf ( \"Nombre d'arguments = %d \\n \" , argc ); for ( i = 0 ; i < argc ; i ++ ) printf ( \"Argument %d : %s \\n \" , i , argv [ i ]); printf ( \"Variables d'env: \\n \" ); i = 0 ; while ( arge [ i ] != NULL ) { printf ( \"Variable d'Env[%d]=%s \\n \" , i , arge [ i ]); i ++ ; } return 0 ; }","title":"Exercice 1"},{"location":"41_progsys_tp1_proc_corr/#exercice-2","text":"Ecrire un programme de calculatrice simple, qui prends deux nombres ainsi que l'op\u00e9rateur en param\u00e8tres. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdlib.h> int main ( int argc , char * argv [], char * arge []) { //Partie Calculette int o1 , o2 ; char op ; int res ; int i = 0 ; if ( argc != 4 ) { printf ( \" \\t J'attends 3 arguments pass\u00e9s au programme ! \\n \" ); exit ( 0 ); } o1 = atoi ( argv [ 1 ]); o2 = atoi ( argv [ 3 ]); op =* ( argv [ 2 ]); switch ( op ) { case '+' : res = o1 + o2 ; break ; case '-' : res = o1 - o2 ; break ; case '*' : res = o1 * o2 ; break ; case '/' : res = o1 / o2 ; break ; default : printf ( \"erreur d'operande \\n \" ); } printf ( \"res=%d \\n \" , res ); return 0 ; }","title":"Exercice 2"},{"location":"41_progsys_tp1_proc_corr/#zombie-war","text":"","title":"Zombie War"},{"location":"41_progsys_tp1_proc_corr/#exercice-3","text":"Ecrire un programme en C qui cr\u00e9er deux processus et qui met en valeur le ph\u00e9nom\u00e8ne des processus zombie . Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { pid_t pid ; pid = fork (); if ( pid == -1 ) { printf ( \"Error on fork \\n \" ); exit ( -1 ); } if ( pid == 0 ) { printf ( \"FILS : mon pid = %d et celui de mon pere est %d \\n \" , getpid (), getppid ()); sleep ( 10 ); printf ( \">>> mort du fils \\n \" ); } else { printf ( \" PERE : mon pid = %d, j'attends la mort de mon fils \\n \" , getpid ()); sleep ( 20 ); //Pendant 10 sec on observe le zombie ... exit ( 0 ); } } Le corriger pour le rendre \u00ab propre \u00bb ! Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { pid_t pid ; pid = fork (); if ( pid == -1 ) { printf ( \"Error on fork \\n \" ); exit ( -1 ); } if ( pid == 0 ) { printf ( \"FILS : mon pid = %d et celui de mon pere est %d \\n \" , getpid (), getppid ()); sleep ( 10 ); printf ( \">>> mort du fils \\n \" ); exit ( 0 ); } else { printf ( \" PERE : mon pid = %d, j'attends la mort de mon fils \\n \" , getpid ()); wait ( NULL ); printf ( \"Pere : j'ai recut la mort de mon fils, je peux mourir en Paix. RIP. \\n \" ); sleep ( 10 ); // Pendant ces 10 sec, on n'observe PLUS de Zombie :) exit ( 0 ); } }","title":"Exercice 3"},{"location":"41_progsys_tp2_proc/","text":"Programmation Syst\u00e8me : TP2 - Fork/Execv \u00b6 Sur Papier \u00b6 Exercice 1 : Arbre g\u00e9n\u00e9alogique \u00b6 On a le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main () { int p1 , p2 , p3 ; p1 = p2 = p3 = -1 ; p1 = fork (); p2 = fork (); p3 = fork (); if ( p1 == 0 ) execv ( \"F1\" , NULL ); if ( p2 == 0 ) execv ( \"F2\" , NULL ); if ( p3 == 0 ) execv ( \"F3\" , NULL ); pause (); exit ( 0 ); } Combien de processus s'executent ? Sur quels programmes (P\u00e8re, F1, F2 et F3) ? Justifiez vos r\u00e9ponses en dessinant un arbre g\u00e9n\u00e9alogique. Exercice 2 : Lecture de code \u00b6 On suppose que le pid du p\u00e8re est 100 et celui du fils 200, quelles sont les valeurs affich\u00e9es par le programme ci-dessous ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int x = 0 ; x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); pid = fork (); if ( pid == 0 ) { x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } else printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } A coder ! \u00b6 Exercice 3 : fork() \u00b6 Dans un m\u00eame programme , un processus en active un autre et se met en attente de la fin de celui-ci, r\u00e9cup\u00e8re le mot d\u2019\u00e9tat (valeur retourn\u00e9e par exit() ) transmis et l\u2019affiche. Chacun des processus affiche son PID et celui de son p\u00e8re. Le p\u00e8re affiche en plus le PID de son fils. Tip Les simples mots \"Dans un m\u00eame programme\" impliquent un fork() ! Exercice 4 : execv() \u00b6 Un processus (programme P) en active un autre F en lui transmettant une chaine de caract\u00e8res saisie au clavier. F calcule la longueur de la chaine et la transmet comme mot d\u2019\u00e9tat \u00e0 P . P affiche la longueur. Tip Les simples mots \"Un programme ... en active un autre \" impliquent : fork() + execv() !","title":"Programmation Syst\u00e8me - TP2 Fork/Execv"},{"location":"41_progsys_tp2_proc/#programmation-systeme-tp2-forkexecv","text":"","title":"Programmation Syst\u00e8me : TP2 - Fork/Execv"},{"location":"41_progsys_tp2_proc/#sur-papier","text":"","title":"Sur Papier"},{"location":"41_progsys_tp2_proc/#exercice-1-arbre-genealogique","text":"On a le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main () { int p1 , p2 , p3 ; p1 = p2 = p3 = -1 ; p1 = fork (); p2 = fork (); p3 = fork (); if ( p1 == 0 ) execv ( \"F1\" , NULL ); if ( p2 == 0 ) execv ( \"F2\" , NULL ); if ( p3 == 0 ) execv ( \"F3\" , NULL ); pause (); exit ( 0 ); } Combien de processus s'executent ? Sur quels programmes (P\u00e8re, F1, F2 et F3) ? Justifiez vos r\u00e9ponses en dessinant un arbre g\u00e9n\u00e9alogique.","title":"Exercice 1 : Arbre g\u00e9n\u00e9alogique"},{"location":"41_progsys_tp2_proc/#exercice-2-lecture-de-code","text":"On suppose que le pid du p\u00e8re est 100 et celui du fils 200, quelles sont les valeurs affich\u00e9es par le programme ci-dessous ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int x = 0 ; x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); pid = fork (); if ( pid == 0 ) { x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } else printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); }","title":"Exercice 2 : Lecture de code"},{"location":"41_progsys_tp2_proc/#a-coder","text":"","title":"A coder !"},{"location":"41_progsys_tp2_proc/#exercice-3-fork","text":"Dans un m\u00eame programme , un processus en active un autre et se met en attente de la fin de celui-ci, r\u00e9cup\u00e8re le mot d\u2019\u00e9tat (valeur retourn\u00e9e par exit() ) transmis et l\u2019affiche. Chacun des processus affiche son PID et celui de son p\u00e8re. Le p\u00e8re affiche en plus le PID de son fils. Tip Les simples mots \"Dans un m\u00eame programme\" impliquent un fork() !","title":"Exercice 3 : fork()"},{"location":"41_progsys_tp2_proc/#exercice-4-execv","text":"Un processus (programme P) en active un autre F en lui transmettant une chaine de caract\u00e8res saisie au clavier. F calcule la longueur de la chaine et la transmet comme mot d\u2019\u00e9tat \u00e0 P . P affiche la longueur. Tip Les simples mots \"Un programme ... en active un autre \" impliquent : fork() + execv() !","title":"Exercice 4 : execv()"},{"location":"41_progsys_tp2_proc_corr/","text":"Programmation Syst\u00e8me : TP2 - Processus \u00b6 Sur Papier \u00b6 Exercice 1 : Arbre g\u00e9n\u00e9alogique \u00b6 On a le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main () { int p1 , p2 , p3 ; p1 = p2 = p3 = -1 ; p1 = fork (); p2 = fork (); p3 = fork (); if ( p1 == 0 ) execv ( \"F1\" , NULL ); if ( p2 == 0 ) execv ( \"F2\" , NULL ); if ( p3 == 0 ) execv ( \"F3\" , NULL ); pause (); exit ( 0 ); } Combien de processus s'executent ? Sur quels programmes (P\u00e8re, F1, F2 et F3) ? Justifiez vos r\u00e9ponses en dessinant un arbre g\u00e9n\u00e9alogique. Exercice 2 : Lecture de code \u00b6 On suppose que le pid du p\u00e8re est 100 et celui du fils 200, quelles sont les valeurs affich\u00e9es par le programme ci-dessous ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int x = 0 ; x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); pid = fork (); if ( pid == 0 ) { x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } else printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } Solution 1 2 3 4 5 mon pid est 100 x = 1 mon pid est 200 x = 2 mon pid est 200 x = 2 mon pid est 100 x = 1 mon pid est 100 x = 1 L'ordre d'affichage peut chnager selon l'orde de passage de processus ! Cela d\u00e9pends du timing, de l'algo d'ordonnacement en vigueur etc ... A coder ! \u00b6 Exercice 3 : fork() \u00b6 Dans un m\u00eame programme , un processus en active un autre et se met en attente de la fin de celui-ci, r\u00e9cup\u00e8re le mot d\u2019\u00e9tat (valeur retourn\u00e9e par exit() ) transmis et l\u2019affiche. Chacun des processus affiche son PID et celui de son p\u00e8re. Le p\u00e8re affiche en plus le PID de son fils. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int status ; pid = fork (); if ( pid == 0 ) { printf ( \" FILS : mon pid est %d \\n \" , getpid ()); printf ( \" FILS : mon ppid est %d \\n \" , getppid ()); exit ( 10 ); } else { printf ( \"PERE : mon pid est %d \\n \" , getpid ()); printf ( \"PERE : mon ppid est %d \\n \" , getppid () ); printf ( \"PERE: mon fils est %d\" , pid ); wait ( & status ); printf ( \" \\n PERE status : %d\" , status >> 8 ); } return 0 ; } Exercice 4 : execv() \u00b6 Un processus (programme P) en active un autre F en lui transmettant une chaine de caract\u00e8res saisie au clavier. F calcule la longueur de la chaine et la transmet comme mot d\u2019\u00e9tat \u00e0 P . P affiche la longueur. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int stat ; char message [ 100 ]; int longueur ; char * argv [ 3 ]; argv [ 0 ] = \"F\" ; argv [ 2 ] = NULL ; printf ( \"Entrez une chaine de caractere : \" ); scanf ( \"%s\" , message ); pid = fork (); argv [ 1 ] = message ; if ( pid == 0 ) { printf ( \" FILS : mon pid est %d \\n \" , getpid ()); printf ( \" FILS : mon ppid est %d \\n \" , getppid ()); execv ( \"F\" , argv ); } else { printf ( \"PERE : mon pid est %d \\n \" , getpid ()); printf ( \"PERE : mon ppid est %d \\n \" , getppid () ); printf ( \"PERE: mon fils est %d\" , pid ); wait ( & stat ); printf ( \" \\n PERE status == longueur message : %d\" , stat >> 8 ); } return 0 ; } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( int argc , char * argv []) { int cpt = 0 ; char * mess ; mess = argv [ 1 ]; while ( mess [ cpt ] != '\\0' ){ cpt ++ ; } printf ( \"FILS : La chaine fait %d \\n \" , cpt ); exit ( cpt ); }","title":""},{"location":"41_progsys_tp2_proc_corr/#programmation-systeme-tp2-processus","text":"","title":"Programmation Syst\u00e8me : TP2 - Processus"},{"location":"41_progsys_tp2_proc_corr/#sur-papier","text":"","title":"Sur Papier"},{"location":"41_progsys_tp2_proc_corr/#exercice-1-arbre-genealogique","text":"On a le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main () { int p1 , p2 , p3 ; p1 = p2 = p3 = -1 ; p1 = fork (); p2 = fork (); p3 = fork (); if ( p1 == 0 ) execv ( \"F1\" , NULL ); if ( p2 == 0 ) execv ( \"F2\" , NULL ); if ( p3 == 0 ) execv ( \"F3\" , NULL ); pause (); exit ( 0 ); } Combien de processus s'executent ? Sur quels programmes (P\u00e8re, F1, F2 et F3) ? Justifiez vos r\u00e9ponses en dessinant un arbre g\u00e9n\u00e9alogique.","title":"Exercice 1 : Arbre g\u00e9n\u00e9alogique"},{"location":"41_progsys_tp2_proc_corr/#exercice-2-lecture-de-code","text":"On suppose que le pid du p\u00e8re est 100 et celui du fils 200, quelles sont les valeurs affich\u00e9es par le programme ci-dessous ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int x = 0 ; x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); pid = fork (); if ( pid == 0 ) { x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } else printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } Solution 1 2 3 4 5 mon pid est 100 x = 1 mon pid est 200 x = 2 mon pid est 200 x = 2 mon pid est 100 x = 1 mon pid est 100 x = 1 L'ordre d'affichage peut chnager selon l'orde de passage de processus ! Cela d\u00e9pends du timing, de l'algo d'ordonnacement en vigueur etc ...","title":"Exercice 2 : Lecture de code"},{"location":"41_progsys_tp2_proc_corr/#a-coder","text":"","title":"A coder !"},{"location":"41_progsys_tp2_proc_corr/#exercice-3-fork","text":"Dans un m\u00eame programme , un processus en active un autre et se met en attente de la fin de celui-ci, r\u00e9cup\u00e8re le mot d\u2019\u00e9tat (valeur retourn\u00e9e par exit() ) transmis et l\u2019affiche. Chacun des processus affiche son PID et celui de son p\u00e8re. Le p\u00e8re affiche en plus le PID de son fils. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int status ; pid = fork (); if ( pid == 0 ) { printf ( \" FILS : mon pid est %d \\n \" , getpid ()); printf ( \" FILS : mon ppid est %d \\n \" , getppid ()); exit ( 10 ); } else { printf ( \"PERE : mon pid est %d \\n \" , getpid ()); printf ( \"PERE : mon ppid est %d \\n \" , getppid () ); printf ( \"PERE: mon fils est %d\" , pid ); wait ( & status ); printf ( \" \\n PERE status : %d\" , status >> 8 ); } return 0 ; }","title":"Exercice 3 : fork()"},{"location":"41_progsys_tp2_proc_corr/#exercice-4-execv","text":"Un processus (programme P) en active un autre F en lui transmettant une chaine de caract\u00e8res saisie au clavier. F calcule la longueur de la chaine et la transmet comme mot d\u2019\u00e9tat \u00e0 P . P affiche la longueur. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int stat ; char message [ 100 ]; int longueur ; char * argv [ 3 ]; argv [ 0 ] = \"F\" ; argv [ 2 ] = NULL ; printf ( \"Entrez une chaine de caractere : \" ); scanf ( \"%s\" , message ); pid = fork (); argv [ 1 ] = message ; if ( pid == 0 ) { printf ( \" FILS : mon pid est %d \\n \" , getpid ()); printf ( \" FILS : mon ppid est %d \\n \" , getppid ()); execv ( \"F\" , argv ); } else { printf ( \"PERE : mon pid est %d \\n \" , getpid ()); printf ( \"PERE : mon ppid est %d \\n \" , getppid () ); printf ( \"PERE: mon fils est %d\" , pid ); wait ( & stat ); printf ( \" \\n PERE status == longueur message : %d\" , stat >> 8 ); } return 0 ; } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( int argc , char * argv []) { int cpt = 0 ; char * mess ; mess = argv [ 1 ]; while ( mess [ cpt ] != '\\0' ){ cpt ++ ; } printf ( \"FILS : La chaine fait %d \\n \" , cpt ); exit ( cpt ); }","title":"Exercice 4 : execv()"},{"location":"41_progsys_tp3_sig/","text":"Programmation Syst\u00e8me : TP3 - Signaux \u00b6 Sur Papier \u00b6 Exercice 1 \u00b6 Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void interruption ( int sig ) { printf ( \"UN \\n \" ); } int main ( void ) { signal ( SIGCHLD , interruption ); if ( fork () ) { printf ( \"DEUX \\n \" ); wait ( NULL ); } else printf ( \"TROIS \\n \" ); exit ( 0 ); } Exercice 2 \u00b6 Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <signal.h> #include <stdlib.h> #include <stdio.h> void stop ( int sig ); int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ){ pause (); signal ( SIGUSR1 , stop ); printf ( \"ici le fils: j'attends un signal de mon p\u00e8re \\n ); } else { sleep ( 1 ); printf ( \"ici le pere: j'envoie un signal a mon fils \\n \" ); kill ( pid , SIGUSR1 ); sleep ( 1 ); kill ( pid , SIGKILL ); wait ( NULL ); printf ( \"ici le pere: j'ai arret\u00e9 mon fils \\n \" ); } } void stop ( int sig ) { printf ( \"ici le fils mon pere m'a tu\u00e9 \\n \" ); exit ( 0 ); } A coder ! \u00b6 Exercice 3 \u00b6 Ecrire un programme ex3 qui contr\u00f4le la frappe du caract\u00e8re \"ctrl C\". Les 5 premi\u00e8res fois: affichage de \"Vous avez tape CTRL C\" sur l'\u00e9cran, la 6\u00e8me : arr\u00eat de la t\u00e2che. Exercice 4 \u00b6 Une t\u00e2che m\u00e8re ex4 active une t\u00e2che fille (sur un seul programme). La t\u00e2che fille se met en boucle infinie. La t\u00e2che m\u00e8re lui envoie un signal, la d\u00e9bloquer et attend la fin de la fille. Tip Attention \u00e0 la position de l'appel \u00e0 signal() : par d\u00e9faut, la reception de SIGUSR1 tue le process ... Il faut donc etre sur que le cablage est fait cot\u00e9 fils avant l'appel \u00e0 kill() cot\u00e9 p\u00e8re ! Exercice 5 \u00b6 Une t\u00e2che m\u00e8re ex5 active une t\u00e2che fille ex5f (sur deux programmes).. La t\u00e2che fille se met en boucle infinie. Lorsqu'on tape sur une touche, la m\u00e8re envoie \u00e0 sa fille un signal, la d\u00e9bloque et attend la fin de celle-ci. Exercice 6 \u00b6 Ecrire un programme qui simule un r\u00e9veil en utilisant le signal SIGALRM. Exercice 7 \u00b6 R\u00e9aliser un dispositif r\u00e9veil sans l'utilisation du signal SIGALRM : La t\u00e2che m\u00e8re ex7 active une t\u00e2che fille ex7-2 et lui demande de la r\u00e9veiller au bout d'un certain temps.","title":"Programmation Syst\u00e8me - TP3 Signaux"},{"location":"41_progsys_tp3_sig/#programmation-systeme-tp3-signaux","text":"","title":"Programmation Syst\u00e8me : TP3 - Signaux"},{"location":"41_progsys_tp3_sig/#sur-papier","text":"","title":"Sur Papier"},{"location":"41_progsys_tp3_sig/#exercice-1","text":"Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void interruption ( int sig ) { printf ( \"UN \\n \" ); } int main ( void ) { signal ( SIGCHLD , interruption ); if ( fork () ) { printf ( \"DEUX \\n \" ); wait ( NULL ); } else printf ( \"TROIS \\n \" ); exit ( 0 ); }","title":"Exercice 1"},{"location":"41_progsys_tp3_sig/#exercice-2","text":"Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <signal.h> #include <stdlib.h> #include <stdio.h> void stop ( int sig ); int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ){ pause (); signal ( SIGUSR1 , stop ); printf ( \"ici le fils: j'attends un signal de mon p\u00e8re \\n ); } else { sleep ( 1 ); printf ( \"ici le pere: j'envoie un signal a mon fils \\n \" ); kill ( pid , SIGUSR1 ); sleep ( 1 ); kill ( pid , SIGKILL ); wait ( NULL ); printf ( \"ici le pere: j'ai arret\u00e9 mon fils \\n \" ); } } void stop ( int sig ) { printf ( \"ici le fils mon pere m'a tu\u00e9 \\n \" ); exit ( 0 ); }","title":"Exercice 2"},{"location":"41_progsys_tp3_sig/#a-coder","text":"","title":"A coder !"},{"location":"41_progsys_tp3_sig/#exercice-3","text":"Ecrire un programme ex3 qui contr\u00f4le la frappe du caract\u00e8re \"ctrl C\". Les 5 premi\u00e8res fois: affichage de \"Vous avez tape CTRL C\" sur l'\u00e9cran, la 6\u00e8me : arr\u00eat de la t\u00e2che.","title":"Exercice 3"},{"location":"41_progsys_tp3_sig/#exercice-4","text":"Une t\u00e2che m\u00e8re ex4 active une t\u00e2che fille (sur un seul programme). La t\u00e2che fille se met en boucle infinie. La t\u00e2che m\u00e8re lui envoie un signal, la d\u00e9bloquer et attend la fin de la fille. Tip Attention \u00e0 la position de l'appel \u00e0 signal() : par d\u00e9faut, la reception de SIGUSR1 tue le process ... Il faut donc etre sur que le cablage est fait cot\u00e9 fils avant l'appel \u00e0 kill() cot\u00e9 p\u00e8re !","title":"Exercice 4"},{"location":"41_progsys_tp3_sig/#exercice-5","text":"Une t\u00e2che m\u00e8re ex5 active une t\u00e2che fille ex5f (sur deux programmes).. La t\u00e2che fille se met en boucle infinie. Lorsqu'on tape sur une touche, la m\u00e8re envoie \u00e0 sa fille un signal, la d\u00e9bloque et attend la fin de celle-ci.","title":"Exercice 5"},{"location":"41_progsys_tp3_sig/#exercice-6","text":"Ecrire un programme qui simule un r\u00e9veil en utilisant le signal SIGALRM.","title":"Exercice 6"},{"location":"41_progsys_tp3_sig/#exercice-7","text":"R\u00e9aliser un dispositif r\u00e9veil sans l'utilisation du signal SIGALRM : La t\u00e2che m\u00e8re ex7 active une t\u00e2che fille ex7-2 et lui demande de la r\u00e9veiller au bout d'un certain temps.","title":"Exercice 7"},{"location":"41_progsys_tp3_sig_corr/","text":"Programmation Syst\u00e8me : TP3 - Signaux \u00b6 Sur Papier \u00b6 Exercice 1 \u00b6 Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void interruption ( int sig ) { printf ( \"UN \\n \" ); } int main ( void ) { signal ( SIGCHLD , interruption ); if ( fork () ) { printf ( \"DEUX \\n \" ); wait ( NULL ); } else printf ( \"TROIS \\n \" ); exit ( 0 ); } Solution 1 Solution 2 Solution 3 DEUX -> TROIS -> UN TROIS -> UN -> DEUX TROIS -> DEUX -> UN Exercice 2 \u00b6 Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <signal.h> #include <stdlib.h> #include <stdio.h> void stop ( int sig ); int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ){ pause (); signal ( SIGUSR1 , stop ); printf ( \"ici le fils: j'attends un signal de mon p\u00e8re \\n ); } else { sleep ( 1 ); printf ( \"ici le pere: j'envoie un signal a mon fils \\n \" ); kill ( pid , SIGUSR1 ); sleep ( 1 ); kill ( pid , SIGKILL ); wait ( NULL ); printf ( \"ici le pere: j'ai arret\u00e9 mon fils \\n \" ); } } void stop ( int sig ) { printf ( \"ici le fils mon pere m'a tu\u00e9 \\n \" ); exit ( 0 ); } R\u00e9ponse : ici le pere: j'envoi un signal a mon fils ici le pere: j'ai arrete mon fils A coder ! \u00b6 Exercice 3 \u00b6 Ecrire un programme ex3 qui contr\u00f4le la frappe du caract\u00e8re \"ctrl C\". Les 5 premi\u00e8res fois: affichage de \"Vous avez tape CTRL C\" sur l'\u00e9cran, la 6\u00e8me : arr\u00eat de la t\u00e2che. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <stdlib.h> #include <stdio.h> #include <sys/types.h> #include <unistd.h> #include <sys/wait.h> #include <signal.h> void catchCtrlC () { static int cpt = 0 ; if ( cpt ++ < 5 ) { printf ( \" \\r Vous avez tap\u00e9 CTRL C (x%d) \\n \" , cpt ); if ( cpt == 5 ) signal ( SIGINT , SIG_DFL ); // On r\u00e9tablit le comportement par d\u00e9faut du CTRL C } } int main () { printf ( \"--- DEBUT --- \\n \" ); signal ( SIGINT , catchCtrlC ); // On connecte le nouveau signal pour modifier le comportement lors d'un CTRL C for (;;); // On boucle \u00e0 l'infinie printf ( \"--- FIN --- \\n \" ); return 0 ; } Version variable globale (moins bien ...) : Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> int n = 0 ; void fonc ( int sig ); int main ( void ) { signal ( SIGINT , fonc ); printf ( \"[Main] je boucle \\n \" ); while ( n < 5 ) { printf ( \"[Main] appuyer sur CTRL C \\n \" ); pause (); } return 0 ; } void fonc ( int sig ) { printf ( \"[fonc] num signal re\u00e7u =<%d> \\n \" , sig ); n ++ ; printf ( \"[fonc] appuyer sur CTRL C- <%d> \\n \" , n ); } Exercice 4 \u00b6 Une t\u00e2che m\u00e8re ex4 active une t\u00e2che fille (sur un seul programme). La t\u00e2che fille se met en boucle infinie. La t\u00e2che m\u00e8re lui envoie un signal, la d\u00e9bloquer et attend la fin de la fille. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> void stop ( int sig ){ printf ( \" FILLE : Ma m\u00e8re m'arr\u00eate en m'envoyant le signal %d \\n \" , sig ); exit ( 0 ); } int main ( void ){ int pid ; pid = fork (); signal ( SIGUSR1 , stop ); if ( pid == 0 ){ for (;;){ printf ( \" FILLE BOUCLE \\n \" ); sleep ( 1 ); } } else { printf ( \" MERE : j'arr\u00eate la fille \\n \" ); kill ( pid , SIGUSR1 ); wait ( NULL ); } } Exercice 5 \u00b6 Une t\u00e2che m\u00e8re ex5 active une t\u00e2che fille ex5f (sur deux programmes).. La t\u00e2che fille se met en boucle infinie. Lorsqu'on tape sur une touche, la m\u00e8re envoie \u00e0 sa fille un signal, la d\u00e9bloque et attend la fin de celle-ci. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> int main ( void ) { int pid , status ; char ch ; char * argv [ 2 ]; pid = fork (); if ( pid == 0 ){ argv [ 0 ] = \"exo5F\" ; argv [ 1 ] = NULL ; execv ( \"exo5F\" , argv ); } else { printf ( \"PARENT : press key to stop child \\n \" ); scanf ( \"%c\" , & ch ); kill ( pid , SIGUSR1 ); wait ( & status ); printf ( \"PARENT : Child stopped with status %d \\n \" , status >> 8 ); } } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> void stop ( int sig ){ printf ( \"CHILD : Stopped by parent with signal %d \\n \" , sig ); exit ( 3 ); } int main ( void ) { signal ( SIGUSR1 , stop ); for (;;) { printf ( \"CHILD : LOOPING \\n \" ); sleep ( 1 ); } } Exercice 6 \u00b6 Ecrire un programme qui simule un r\u00e9veil en utilisant le signal SIGALRM. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> void reveil ( int sig ){ printf ( \" BIP BIP BOP !!!! \\n \" ); exit ( 0 ); } int main ( void ) { int i = 0 ; int car ; printf ( \"Dans cb de temps veux-tu te lever ?\" ); scanf ( \"%d\" , & car ); alarm ( car ); signal ( SIGALRM , reveil ); for (;;){ i ++ ; printf ( \"Tu dors depuis %d sec \\n \" , i ); sleep ( 1 ); } } Exercice 7 \u00b6 R\u00e9aliser un dispositif r\u00e9veil sans l'utilisation du signal SIGALRM : La t\u00e2che m\u00e8re ex7 active une t\u00e2che fille ex7-2 et lui demande de la r\u00e9veiller au bout d'un certain temps. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> void reveil ( int sig ){ printf ( \" BIP BIP BOP !!!! \\n \" ); wait ( NULL ); exit ( 0 ); } int main ( void ) { int delai , pid ; char heure [ 10 ]; char * argv [ 3 ]; signal ( SIGUSR1 , reveil ); printf ( \"MERE : Entrez l'heure de reveil : \" ); scanf ( \"%d\" , & delai ); sprintf ( heure , \"%d\" , delai ); pid = fork (); if ( pid == 0 ) { argv [ 0 ] = \"exo7F\" ; argv [ 1 ] = heure ; argv [ 2 ] = NULL ; execv ( \"exo7F\" , argv ); } printf ( \"MERE : J'attends le reveil de ma fille dans %d sec \\n \" , delai ); pause (); } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> int main ( int argc , char * argv []) { int delai , i ; delai = atoi ( argv [ 1 ]); printf ( \"FILLE \\n \" ); for ( i = delai ; i > 0 ; i -- ) { printf ( \" Je reveille ma m\u00e8re dans %d \\n \" , i ); sleep ( 1 ); } kill ( getppid (), SIGUSR1 ); exit ( 0 ); }","title":""},{"location":"41_progsys_tp3_sig_corr/#programmation-systeme-tp3-signaux","text":"","title":"Programmation Syst\u00e8me : TP3 - Signaux"},{"location":"41_progsys_tp3_sig_corr/#sur-papier","text":"","title":"Sur Papier"},{"location":"41_progsys_tp3_sig_corr/#exercice-1","text":"Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void interruption ( int sig ) { printf ( \"UN \\n \" ); } int main ( void ) { signal ( SIGCHLD , interruption ); if ( fork () ) { printf ( \"DEUX \\n \" ); wait ( NULL ); } else printf ( \"TROIS \\n \" ); exit ( 0 ); } Solution 1 Solution 2 Solution 3 DEUX -> TROIS -> UN TROIS -> UN -> DEUX TROIS -> DEUX -> UN","title":"Exercice 1"},{"location":"41_progsys_tp3_sig_corr/#exercice-2","text":"Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <signal.h> #include <stdlib.h> #include <stdio.h> void stop ( int sig ); int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ){ pause (); signal ( SIGUSR1 , stop ); printf ( \"ici le fils: j'attends un signal de mon p\u00e8re \\n ); } else { sleep ( 1 ); printf ( \"ici le pere: j'envoie un signal a mon fils \\n \" ); kill ( pid , SIGUSR1 ); sleep ( 1 ); kill ( pid , SIGKILL ); wait ( NULL ); printf ( \"ici le pere: j'ai arret\u00e9 mon fils \\n \" ); } } void stop ( int sig ) { printf ( \"ici le fils mon pere m'a tu\u00e9 \\n \" ); exit ( 0 ); } R\u00e9ponse : ici le pere: j'envoi un signal a mon fils ici le pere: j'ai arrete mon fils","title":"Exercice 2"},{"location":"41_progsys_tp3_sig_corr/#a-coder","text":"","title":"A coder !"},{"location":"41_progsys_tp3_sig_corr/#exercice-3","text":"Ecrire un programme ex3 qui contr\u00f4le la frappe du caract\u00e8re \"ctrl C\". Les 5 premi\u00e8res fois: affichage de \"Vous avez tape CTRL C\" sur l'\u00e9cran, la 6\u00e8me : arr\u00eat de la t\u00e2che. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <stdlib.h> #include <stdio.h> #include <sys/types.h> #include <unistd.h> #include <sys/wait.h> #include <signal.h> void catchCtrlC () { static int cpt = 0 ; if ( cpt ++ < 5 ) { printf ( \" \\r Vous avez tap\u00e9 CTRL C (x%d) \\n \" , cpt ); if ( cpt == 5 ) signal ( SIGINT , SIG_DFL ); // On r\u00e9tablit le comportement par d\u00e9faut du CTRL C } } int main () { printf ( \"--- DEBUT --- \\n \" ); signal ( SIGINT , catchCtrlC ); // On connecte le nouveau signal pour modifier le comportement lors d'un CTRL C for (;;); // On boucle \u00e0 l'infinie printf ( \"--- FIN --- \\n \" ); return 0 ; } Version variable globale (moins bien ...) : Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> int n = 0 ; void fonc ( int sig ); int main ( void ) { signal ( SIGINT , fonc ); printf ( \"[Main] je boucle \\n \" ); while ( n < 5 ) { printf ( \"[Main] appuyer sur CTRL C \\n \" ); pause (); } return 0 ; } void fonc ( int sig ) { printf ( \"[fonc] num signal re\u00e7u =<%d> \\n \" , sig ); n ++ ; printf ( \"[fonc] appuyer sur CTRL C- <%d> \\n \" , n ); }","title":"Exercice 3"},{"location":"41_progsys_tp3_sig_corr/#exercice-4","text":"Une t\u00e2che m\u00e8re ex4 active une t\u00e2che fille (sur un seul programme). La t\u00e2che fille se met en boucle infinie. La t\u00e2che m\u00e8re lui envoie un signal, la d\u00e9bloquer et attend la fin de la fille. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> void stop ( int sig ){ printf ( \" FILLE : Ma m\u00e8re m'arr\u00eate en m'envoyant le signal %d \\n \" , sig ); exit ( 0 ); } int main ( void ){ int pid ; pid = fork (); signal ( SIGUSR1 , stop ); if ( pid == 0 ){ for (;;){ printf ( \" FILLE BOUCLE \\n \" ); sleep ( 1 ); } } else { printf ( \" MERE : j'arr\u00eate la fille \\n \" ); kill ( pid , SIGUSR1 ); wait ( NULL ); } }","title":"Exercice 4"},{"location":"41_progsys_tp3_sig_corr/#exercice-5","text":"Une t\u00e2che m\u00e8re ex5 active une t\u00e2che fille ex5f (sur deux programmes).. La t\u00e2che fille se met en boucle infinie. Lorsqu'on tape sur une touche, la m\u00e8re envoie \u00e0 sa fille un signal, la d\u00e9bloque et attend la fin de celle-ci. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> int main ( void ) { int pid , status ; char ch ; char * argv [ 2 ]; pid = fork (); if ( pid == 0 ){ argv [ 0 ] = \"exo5F\" ; argv [ 1 ] = NULL ; execv ( \"exo5F\" , argv ); } else { printf ( \"PARENT : press key to stop child \\n \" ); scanf ( \"%c\" , & ch ); kill ( pid , SIGUSR1 ); wait ( & status ); printf ( \"PARENT : Child stopped with status %d \\n \" , status >> 8 ); } } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> void stop ( int sig ){ printf ( \"CHILD : Stopped by parent with signal %d \\n \" , sig ); exit ( 3 ); } int main ( void ) { signal ( SIGUSR1 , stop ); for (;;) { printf ( \"CHILD : LOOPING \\n \" ); sleep ( 1 ); } }","title":"Exercice 5"},{"location":"41_progsys_tp3_sig_corr/#exercice-6","text":"Ecrire un programme qui simule un r\u00e9veil en utilisant le signal SIGALRM. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> void reveil ( int sig ){ printf ( \" BIP BIP BOP !!!! \\n \" ); exit ( 0 ); } int main ( void ) { int i = 0 ; int car ; printf ( \"Dans cb de temps veux-tu te lever ?\" ); scanf ( \"%d\" , & car ); alarm ( car ); signal ( SIGALRM , reveil ); for (;;){ i ++ ; printf ( \"Tu dors depuis %d sec \\n \" , i ); sleep ( 1 ); } }","title":"Exercice 6"},{"location":"41_progsys_tp3_sig_corr/#exercice-7","text":"R\u00e9aliser un dispositif r\u00e9veil sans l'utilisation du signal SIGALRM : La t\u00e2che m\u00e8re ex7 active une t\u00e2che fille ex7-2 et lui demande de la r\u00e9veiller au bout d'un certain temps. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> void reveil ( int sig ){ printf ( \" BIP BIP BOP !!!! \\n \" ); wait ( NULL ); exit ( 0 ); } int main ( void ) { int delai , pid ; char heure [ 10 ]; char * argv [ 3 ]; signal ( SIGUSR1 , reveil ); printf ( \"MERE : Entrez l'heure de reveil : \" ); scanf ( \"%d\" , & delai ); sprintf ( heure , \"%d\" , delai ); pid = fork (); if ( pid == 0 ) { argv [ 0 ] = \"exo7F\" ; argv [ 1 ] = heure ; argv [ 2 ] = NULL ; execv ( \"exo7F\" , argv ); } printf ( \"MERE : J'attends le reveil de ma fille dans %d sec \\n \" , delai ); pause (); } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <stdio.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> int main ( int argc , char * argv []) { int delai , i ; delai = atoi ( argv [ 1 ]); printf ( \"FILLE \\n \" ); for ( i = delai ; i > 0 ; i -- ) { printf ( \" Je reveille ma m\u00e8re dans %d \\n \" , i ); sleep ( 1 ); } kill ( getppid (), SIGUSR1 ); exit ( 0 ); }","title":"Exercice 7"},{"location":"41_progsys_tp4_fic/","text":"Programmation Syst\u00e8me : TP4 - Fichiers \u00b6 Exercice 1 : Chaine vs. Int \u00b6 \u00c9crire un programme en C qui : Ouvre (cr\u00e9er si n\u2019existe pas) un fichier \u00ab test \u00bb , en lecture et \u00e9criture. Affiche son descripteur de fichier Y \u00e9crit une chaine de caract\u00e8res ainsi qu\u2019un entier Affiche la position du curseur de fichier Le replace au d\u00e9but du fichier Relis le fichier Ferme les descripteur proprement et se termine.","title":"Programmation Syst\u00e8me - TP4 Fichiers"},{"location":"41_progsys_tp4_fic/#programmation-systeme-tp4-fichiers","text":"","title":"Programmation Syst\u00e8me : TP4 - Fichiers"},{"location":"41_progsys_tp4_fic/#exercice-1-chaine-vs-int","text":"\u00c9crire un programme en C qui : Ouvre (cr\u00e9er si n\u2019existe pas) un fichier \u00ab test \u00bb , en lecture et \u00e9criture. Affiche son descripteur de fichier Y \u00e9crit une chaine de caract\u00e8res ainsi qu\u2019un entier Affiche la position du curseur de fichier Le replace au d\u00e9but du fichier Relis le fichier Ferme les descripteur proprement et se termine.","title":"Exercice 1 : Chaine vs. Int"},{"location":"41_progsys_tp4_fic_corr/","text":"Programmation Syst\u00e8me : TP3 Signaux \u00b6 Exercice 1 : Chaine vs. Int \u00b6 \u00c9crire un programme en C qui : Ouvre (cr\u00e9er si n\u2019existe pas) un fichier \u00ab test \u00bb , en lecture et \u00e9criture. Affiche son descripteur de fichier Y \u00e9crit une chaine de caract\u00e8res ainsi qu\u2019un entier Affiche la position du curseur de fichier Le replace au d\u00e9but du fichier Relis le fichier Ferme les descripteur proprement et se termine. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <fcntl.h> #include <sys/types.h> int main ( void ) { int desc = open ( \"test\" , O_RDWR | O_CREAT , 0750 ); printf ( \"Le desc de fichier vaut : %d \\n \" , desc ); char c [ 6 ] = \"chaine\" ; int x = 97 ; write ( desc , c , sizeof ( c )); write ( desc , & x , sizeof ( x )); int pos = lseek ( desc , 0 , SEEK_CUR ); printf ( \"Position courante du curseur : %d \\n \" , pos ); pos = lseek ( desc , 0 , SEEK_SET ); printf ( \"Nouvelle position courante du curseur : %d \\n \" , pos ); char cl [ 6 ]; int nb , xl ; nb = read ( desc , cl , 6 ); printf ( \" C : '%s' avec nb octets lus : %d \\n \" , cl , nb ); nb = read ( desc , & xl , sizeof ( int )); printf ( \" X : '%d' avec nb octets lus : %d \\n \" , xl , nb ); printf ( \"Taille d'un INT : %lu \\n \" , sizeof ( int )); close ( desc ); return 0 ; }","title":""},{"location":"41_progsys_tp4_fic_corr/#programmation-systeme-tp3-signaux","text":"","title":"Programmation Syst\u00e8me : TP3 Signaux"},{"location":"41_progsys_tp4_fic_corr/#exercice-1-chaine-vs-int","text":"\u00c9crire un programme en C qui : Ouvre (cr\u00e9er si n\u2019existe pas) un fichier \u00ab test \u00bb , en lecture et \u00e9criture. Affiche son descripteur de fichier Y \u00e9crit une chaine de caract\u00e8res ainsi qu\u2019un entier Affiche la position du curseur de fichier Le replace au d\u00e9but du fichier Relis le fichier Ferme les descripteur proprement et se termine. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <fcntl.h> #include <sys/types.h> int main ( void ) { int desc = open ( \"test\" , O_RDWR | O_CREAT , 0750 ); printf ( \"Le desc de fichier vaut : %d \\n \" , desc ); char c [ 6 ] = \"chaine\" ; int x = 97 ; write ( desc , c , sizeof ( c )); write ( desc , & x , sizeof ( x )); int pos = lseek ( desc , 0 , SEEK_CUR ); printf ( \"Position courante du curseur : %d \\n \" , pos ); pos = lseek ( desc , 0 , SEEK_SET ); printf ( \"Nouvelle position courante du curseur : %d \\n \" , pos ); char cl [ 6 ]; int nb , xl ; nb = read ( desc , cl , 6 ); printf ( \" C : '%s' avec nb octets lus : %d \\n \" , cl , nb ); nb = read ( desc , & xl , sizeof ( int )); printf ( \" X : '%d' avec nb octets lus : %d \\n \" , xl , nb ); printf ( \"Taille d'un INT : %lu \\n \" , sizeof ( int )); close ( desc ); return 0 ; }","title":"Exercice 1 : Chaine vs. Int"}]}